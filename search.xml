<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="posts/16107.html"/>
      <url>posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Arch Linux 安装</title>
      <link href="posts/1.html"/>
      <url>posts/1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Arch-Linux-安装"><a href="#Arch-Linux-安装" class="headerlink" title="Arch Linux 安装"></a>Arch Linux 安装</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/freerqy/p/8502838.html">在VMWare上安装Arch Linux</a></li><li><a href="https://www.viseator.com/2017/05/19/arch_setup/">ArchLinux安装后的必须配置与图形界面安装教程</a></li></ul><h2 id="一、-安装前的准备"><a href="#一、-安装前的准备" class="headerlink" title="一、 安装前的准备"></a>一、 安装前的准备</h2><h3 id="1-制作Arch-Linux启动盘-LIve-CD"><a href="#1-制作Arch-Linux启动盘-LIve-CD" class="headerlink" title="1. 制作Arch Linux启动盘 (LIve CD)"></a>1. 制作Arch Linux启动盘 (LIve CD)</h3><ul><li><p>如果是在虚拟机中安装<strong>Arch linux</strong>，仅需将镜像文件应用于虚拟机中即可，我使用的是VMware，步骤为 <em>虚拟机 -&gt; 设置 -&gt; 硬件 -&gt; CD/DVD -&gt; 使用ISO镜像文件 -&gt; 浏览（找到镜像文件的位置）</em>。</p></li><li><p>如果是安转实体机需要制作<strong>Live CD（自生系统）</strong>，这一步有多种可选择的方法。</p></li></ul><h4 id="1-1-下载并校验镜像文件"><a href="#1-1-下载并校验镜像文件" class="headerlink" title="1.1. 下载并校验镜像文件"></a>1.1. 下载并校验镜像文件</h4><p>可以再<a href="https://www.archlinux.org/download/">Arch Linux官网</a>下载镜像文件，它的 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwiki.archlinux.org%2Findex.php%2FGnuPG">GnuPG</a> 签名可以从下载页面中找到。</p><h4 id="1-2-制作Live-CD"><a href="#1-2-制作Live-CD" class="headerlink" title="1.2. 制作Live CD"></a>1.2. 制作Live CD</h4><ul><li><p>使用<strong>Ultra ISo、Rufus</strong>等工具进行刻录制作Live CD。</p></li><li><p>在Linux下使用命令进行刻录</p><p>  首先你需要查看U盘，找到U盘的设备文件</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">  # sudo fdisk -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  然后使用 <code>dd</code>命令进行刻录</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">  # dd bs=4M if=/path/to/archlinux.iso of=/dev/sdb status=progress oflag=sync<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  其中，<code>/path/to/archlinux.iso</code>为arch镜像路径，<code>/dev/sdb</code>为上一步中查看的U盘分区，使用<code>oflag</code>来控制输出（写入数据）时的行为特征，确保命令结束时数据及元数据真正吸入磁盘，而不是刚写入缓存就返回，<code>status=LEVEL</code>用来控制<code>dd</code>程序的输出信息，<code>LEVEL</code>有三个选项<code>none</code>、<code>noxfer</code>和<code>progress</code>，默认是<code>progress</code>，<code>none</code>的意思是不输出任何相关信息，除非是出错信息，<code>noxfer</code>不会输出最后的统计信息，而<code>progress</code>会输出所有信息。</p></li></ul><h3 id="2-启动Live-CD"><a href="#2-启动Live-CD" class="headerlink" title="2. 启动Live CD"></a>2. 启动<strong>Live CD</strong></h3><p>根据所使用的硬件设备，如U盘、DVD等，可以修改启动顺序或者在启动菜单中选择启动项来启动Live CD。</p><h3 id="3-配置Live-CD环境"><a href="#3-配置Live-CD环境" class="headerlink" title="3. 配置Live CD环境"></a>3. 配置<strong>Live CD</strong>环境</h3><h4 id="3-1-验证启动模式"><a href="#3-1-验证启动模式" class="headerlink" title="3.1. 验证启动模式"></a>3.1. 验证启动模式</h4><p>如果在UEFI主板上启用 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwiki.archlinux.org%2Findex.php%2FUEFI">UEFI</a> 模式，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwiki.archlinux.org%2Findex.php%2FArchiso">Archiso</a> 将会使用 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwiki.archlinux.org%2Findex.php%2FSystemd-boot_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87">systemd-boot</a>) 来启动 Arch Linux 。</p><p>可以列出 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwiki.archlinux.org%2Findex.php%2FUEFI%23UEFI_variables">efivars</a> 目录一验证启动模式。</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># ls /sys/firmware/efi/efivars<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果命令没有错误，则系统以 UEFI 模式启东，如果目录不存在，系统肯恩工艺 BIOS 或 CSM 模式 启动。</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># cat /sys/firmware/efi/fw_platform_size<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果启动该模式为UEFI模式，该命令会返回一个数值，如果数值为64，表示使用的是64-bit (x86_64) UEFI，如果数值为32，表示使用的是 32-bit (IA32) UEFI。</p><h4 id="3-2-连接因特网"><a href="#3-2-连接因特网" class="headerlink" title="3.2. 连接因特网"></a>3.2. 连接因特网</h4><p>如果是有线网，可以使用下面的命令：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># ip link show      # # dhcpcd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>   如果是无线网，则需使用下面的命令进行配置：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># wifi-menu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   配置完成后，可以使用下面的命令进行测试：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># ping -c 4 www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-3-更新系统时间"><a href="#3-3-更新系统时间" class="headerlink" title="3.3. 更新系统时间"></a>3.3. 更新系统时间</h4><p>命令如下：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># timedatectl set-ntp true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用<code>timedatectl status</code>命令检查服务状态。</p><h3 id="4-硬盘配置"><a href="#4-硬盘配置" class="headerlink" title="4. 硬盘配置"></a>4. 硬盘配置</h3><h4 id="4-1-查看硬盘分区"><a href="#4-1-查看硬盘分区" class="headerlink" title="4.1. 查看硬盘分区"></a>4.1. 查看硬盘分区</h4><p>可以使用<code>lsblk</code>或<code>fdisk -l</code>来查看分区</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># lsblk# fdisk -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到硬盘设备，可能为<code>/dev/sda</code>或<code>/dev/nvme01</code>之类的，具体视自己的设备而定。</p><h4 id="4-2-建立硬盘分区"><a href="#4-2-建立硬盘分区" class="headerlink" title="4.2. 建立硬盘分区"></a>4.2. 建立硬盘分区</h4><p>分区有多种选择如<code>parted</code>、<code>fdisk</code>等工具，建议选用自己熟悉的工具。</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># fdisk /dev/sdx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，<code>/dev/sdx</code>为目标磁盘。</p><p>下面为 Arch wiki 中的分区示例</p><table style="margin:auto">    <caption><b>BIOS With MBR</b></caption>    <tr>        <th>Mount Point</th>        <th>Partition</th>        <th>Partition Type</th>        <th>Suggetsed Size</th>    </tr>    <tr>        <td>/mnt</td>        <td>/dev/root_partition</td>        <td>Linux</td>        <td>Remainder of the device</td>    </tr>    <tr>        <td>[SWAP]</td>        <td>/dev/swap_partition</td>        <td>Linux Swap</td>        <td>More than 512MiB</td>    </tr></table><br><table>    <caption><b>UEFI With GPT</b></caption>    <tr>        <th>Mount Point</th>        <th>Partition</th>        <th>Partition Type</th>        <th>Suggested Size</th>    </tr>    <tr>        <td>/mnt/boot  OR /mnt/efi</td>        <td>/dev/efi_system_partition</td>        <td>EFI System Partition</td>        <td>At Least 260 Mib</td>    </tr>    <tr>        <td>[SWAP]</td>        <td>/dev/swap_partition</td>        <td>Linux Swap</td>        <td>More than 512MiB</td>    </tr>    <tr>        <td>/mnt</td>        <td>/dev/root_partition</td>        <td>Linux x86-64 root(/)</td>        <td>Remainder of the device</td>    </tr></table><h4 id="4-3-格式化分区"><a href="#4-3-格式化分区" class="headerlink" title="4.3. 格式化分区"></a>4.3. 格式化分区</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">  # mkfs.fat  /dev/sdax      # 格式化EFI分区  # mkfs.ext4 /dev/sdax    # 格式化根分区  # mkswap /dev/sdax      # 格式化交换分区  # swapon /dev/sdax       # 打开swap分区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-4-挂载分区"><a href="#4-4-挂载分区" class="headerlink" title="4.4. 挂载分区"></a>4.4. 挂载分区</h4><p>挂载是有顺序的，按照文件系统目录结构，先挂载顶层目录，在这里，我们先挂载根分区，然后挂载启动分区</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># mount /dev/sdax /mnt  # 将根分区挂载到/mnt# mkdir -p /mnt/boot/EFI# mount /dev/sdax /mnt/boot/EFI  # 将EFI分区挂载到/mnt/boot/EFI<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><h3 id="1-更换镜像源"><a href="#1-更换镜像源" class="headerlink" title="1. 更换镜像源"></a>1. 更换镜像源</h3><p>修改<code>/etc/pacman.d/mirrorlist</code>文件中的内容，找到对应的地区镜像源并将其剪切到源列表头部即可。这里我们使用 vim 编辑器。</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># vim /etc/pacman.d/mirrorlist<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行上面的命令行后，输入<code>/China</code>按<kbd>Enter</kbd>进行搜索，找到中国的源，如中科大USTC源、清华tuan源等任意一个即可。按<code>2dd</code>剪切后按<code>gg</code>回到文件头部，在将光标向下移动到列表头部按<code>p</code>粘贴后，保存退出即可。</p><h3 id="2-安装必须的软件包"><a href="#2-安装必须的软件包" class="headerlink" title="2. 安装必须的软件包"></a>2. 安装必须的软件包</h3><p>使用 <code>pacstrap</code> 脚本，安装 <code>base</code> 软件包和 Linux 内核以及常规硬件的固件。</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># pacstrap /mnt base base-devel linux linux-firmware<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行完上面的命令行后，系统的基础环境就安装好了，接下来我们还需要进行一些必要的配置和工具的安装。</p><h2 id="三、-系统基本配置"><a href="#三、-系统基本配置" class="headerlink" title="三、 系统基本配置"></a>三、 系统基本配置</h2><h3 id="1-fstab"><a href="#1-fstab" class="headerlink" title="1. fstab"></a>1. fstab</h3><p>fstab 文件是用于定义磁盘分区，各种其他块设备或远程文件系统应如何装入文件系统的。</p><p>在启动时，系统会根据该文件的描述自动挂载分区。</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># genfstab -U /mnt >> /mnt/etc/fstab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查生成的<code>/mnt/etc/fstab</code>文件是否正确</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># cat /mnt/etc/fstab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-Chroot"><a href="#2-Chroot" class="headerlink" title="2. Chroot"></a>2. Chroot</h3><p>Change root into the new system</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># arch-chroot /mnt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-时区"><a href="#3-时区" class="headerlink" title="3. 时区"></a>3. 时区</h3><p>一般的格式为：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># ln -sf /usr/share/zoneinfo/Region/City /etc/localtime<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在中国，我们可以使用下面的命令行：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-本地化"><a href="#4-本地化" class="headerlink" title="4. 本地化"></a>4. 本地化</h3><p>本地化的程序与库若要本地化，都依赖 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwiki.archlinux.org%2Findex.php%2FLocale">Locale</a> ，后者明确规定地域、货币、时区日期的格式、字符排列方式和其他本地化标准等等。在下面两个文件设置：<code>locale.gen</code>与<code>locale.conf</code>。</p><p><code>/etc/locale.gen</code>是一个仅包含注释文档的文本文件。指定更需要的本地化类型，只需移除对应行前面的注释符号（<code>#</code>）即可，建议选择带<code>UTF-8</code>的项，使用下面的命令打开<code>locale.gen</code>文件：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># vim /etc/locale.gen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找到下面3项，去掉没项前面的<code>#</code>即可：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">en_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8zh_TW.UTF-8 UTF-8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行<code>locale-gen</code>以生成 locale 讯息：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># locale-gen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建<code>locale.conf</code>并编辑 设定 LANG 变量</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># vim /etc/locale.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将下面的内容写入<code>locale.conf</code>文件中：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">LANG=en_US.UTF-8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-设置主机名"><a href="#5-设置主机名" class="headerlink" title="5. 设置主机名"></a>5. 设置主机名</h3><p>创建<code>/et/hostname</code>文件并将主机名写入该文件。如下主机名为 archlinux:</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># echo archlinux > /etc/hostname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后配置主机名对应的IP到<code>/etc/hosts</code>中：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># vim /etc/hosts # vim可以使用 pacman -S vim 安装<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果 <code>vim</code> 编辑器没有安装可以使用命令 <code>pacman -S vim</code> 进行安装。</p><p>然后根据下面的内容，编辑文件内容，将对应的<code>myhostname</code> 替换成 <code>hostname</code></p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">127.0.0.1    localhost::1            localhost127.0.1.1    myhostname.localdomain    myhostname<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="6-设置root用户密码"><a href="#6-设置root用户密码" class="headerlink" title="6. 设置root用户密码"></a>6. 设置root用户密码</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  输入上述命令后，再输入两次密码即可。</p><h3 id="7-安装引导程序"><a href="#7-安装引导程序" class="headerlink" title="7. 安装引导程序"></a>7. 安装引导程序</h3><p>需要安装 Linux 引导加载程序，才能在安装后启动系统给，可以使用的引导程序可以<a href="https://wiki.archlinux.org/index.php/Boot_loaders_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87">点击查询</a>) 。</p><p>grub 是最常见的选择，这里我们安装 grub 引导加载程序。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># UEFI 启动# pacman -S grub efibootmgr# grub-install --target=x86_64-efi --efi-directory=/boot/EFI --bootloader-id=grub# grub-mkconfig -o /boot/grub/grub.cfg# BIOS 启动# pacman -S grub-bios# grub-install /dev/sda# grub-mkconfig -o /boot/grub/grub.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-重启"><a href="#8-重启" class="headerlink" title="8. 重启"></a>8. 重启</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># exit                # 退回到安装环境# umount -R /mnt    # 卸载新分区# reboot            # 重启<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>到这里我们的系统的基本配置就完成了。</p><h2 id="四、-优化配置"><a href="#四、-优化配置" class="headerlink" title="四、 优化配置"></a>四、 优化配置</h2><h3 id="1-创建新用户"><a href="#1-创建新用户" class="headerlink" title="1. 创建新用户"></a>1. 创建新用户</h3><p>因为使用root用户登录后，root用户拥有系统的所有操作权限，这样对系统操作非常不安全（如一不小心将系统文件删除了怎么办？），所以需要新建一个普通用户，让其对系统的操作收到一定限制，命令格式如下：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># useradd -m -g 初始用户组 -G 额外用户组 -s 登录shell  用户名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">  useradd -m -G wheel -s /bin/bash asd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-删除用户"><a href="#2-删除用户" class="headerlink" title="2. 删除用户"></a>2. 删除用户</h3><p>如果不小心添加了一个不需要的用户，可以将其删除。<code>-r</code>选项表示在删除的时候同时删除器用户目录。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># userdel 用户名 -r<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-允许提权"><a href="#3-允许提权" class="headerlink" title="3. 允许提权"></a>3. 允许提权</h3><p>在一般情况下，如果要将一个用户设为管理员，就要将其加入到<code>wheel</code>用户组中，这样就可以使用su和sudo命令执行需要高级权限的操作，但是在Arch中，<code>wheel</code>用户组默认没有提权的权限。这就需要编辑<code>/etc/sudoers</code>文件，然后找到<code>wheel ALL=(ALL) ALL</code>一行，并取消前面的注释，保存即可。这样，wheel用户组中的用户就可以利用su或者sudo命令来提权了。</p><h3 id="4-网络配置"><a href="#4-网络配置" class="headerlink" title="4. 网络配置"></a>4. 网络配置</h3><h4 id="4-1-无线网络连接"><a href="#4-1-无线网络连接" class="headerlink" title="4.1. 无线网络连接"></a>4.1. 无线网络连接</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 使用 iwctl 工具# pacman -S iwd  # 安装工具# iwctl # 进入配置[iwd]# station list    # 查看开启的无线设备列表[iwd]# device list # 如果列表为空，则查看无线设备列表[iwd]# device wlan0 show # 查看无线设备 wlan0 的状态[iwd]# station wlan0 scan # 扫描WIFI[iwd]# station wlan0 get-network # 显示 WIFI 列表[iwd]# station wlan0 connect ssid # 连接 WIFI ,ssid 为 WIFI 名称# pacman -S iw wpa_supplicant dialog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-有线连接"><a href="#4-2-有线连接" class="headerlink" title="4.2. 有线连接"></a>4.2. 有线连接</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># pacman -S dhcpcd# systemctl start dhcpcd# systemctl enable dhcpcd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="5-添加-archlinuxcn-源"><a href="#5-添加-archlinuxcn-源" class="headerlink" title="5. 添加 archlinuxcn 源"></a>5. 添加 <code>archlinuxcn</code> 源</h3><p>在 <code>/etc/pacman.conf</code> 文件末尾添加以下两行：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">[archlinuxcn]Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后安装 GPG Key</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">sudo pacman -Syusudo pacman -S arhclinuxcn-keyring<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-安装-yay"><a href="#6-安装-yay" class="headerlink" title="6. 安装 yay"></a>6. 安装 <code>yay</code></h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">sudo pacman -S yay<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改 <code>aururl</code></p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">yay --aururl "https://aur.tuna.tsinghua.edu.cn" --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>yay 使用：选项与 pacman 相同</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">pacman -Syy     # apt updatepacman -Syu        # apt update && apt dist-upgradepacman -S [PackageName]        # apt install [PackageName]pacman -Sy [PackageName]    # apt update && aptinstall [PackageName]pacman -R [PackageName]        # apt remove [PackageName]pacman -Rs [PackageName]    # apt remove [PackageName] && apt autoremovepacman -Scc    # apt clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-安装图形界面"><a href="#7-安装图形界面" class="headerlink" title="7. 安装图形界面"></a>7. 安装图形界面</h3><h4 id="7-1-安装-Xorg服务"><a href="#7-1-安装-Xorg服务" class="headerlink" title="7.1. 安装 Xorg服务"></a>7.1. 安装 Xorg服务</h4><p><code>Xorg</code> 是 <code>Linux</code> 下的一个著名的开源图形服务，我们的桌面环境需要 <code>Xorg</code> 的支持。</p><p>执行如下命令安装 <code>Xorg</code> 及相关组件：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">sudo pacman -S xorg xorg-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="7-2-显卡驱动的安装"><a href="#7-2-显卡驱动的安装" class="headerlink" title="7.2. 显卡驱动的安装"></a>7.2. 显卡驱动的安装</h4><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">sudo pacman -S xf86-video-intel # intelsudo pacman -S xf86-video-ati    # amd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="7-4-安装输入设备"><a href="#7-4-安装输入设备" class="headerlink" title="7.4. 安装输入设备"></a>7.4. 安装输入设备</h4><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">sudo pacman -S xf86-input-libinput sudo pacman -S xf86-input-synaptics    # 触摸板驱动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="7-5-安装桌面登录管理器"><a href="#7-5-安装桌面登录管理器" class="headerlink" title="7.5. 安装桌面登录管理器"></a>7.5. 安装桌面登录管理器</h4><p>推荐使用 <code>sddm</code></p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">sudo pacman -S sddm sddm-kcm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="设置开机启动-sddm-服务"><a href="#设置开机启动-sddm-服务" class="headerlink" title="设置开机启动 sddm 服务"></a>设置开机启动 <code>sddm</code> 服务</h5><p>这里就要介绍一下 <code>Arch</code> 下用于管理系统服务的命令 <code>systemctl</code> 了，服务的作用就是字面意思，为我们提供特定的服务，不如 <code>sddm</code> 就为我们提供了启动 <code>xorg</code> 与管理桌面环境的服务。</p><p>命令的使用并不复杂：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">sudo systemctl start [ServerName]    # 启动一项服务sudo systemctl stop [ServerName]    # 停止一项服务sudo systemctl enable [ServerName]    # 开机启动一项服务sudo systemctl disable [ServerName] # 取消开机启动一项服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所以在这里我们就执行下面的命令来设置开机启动 <code>sddm</code>:</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ sudo systemctl enable sddm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改sddm 主题</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">$ sudo sddm --example-config > /etc/sddm.conf# 打开 /sur/share/sddm/themes目录，看看有哪些主题# 修改/etc/sddm.conf, 在 current 行的后面添加主题名称，如： Current = maya<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="7-6-安装桌面环境"><a href="#7-6-安装桌面环境" class="headerlink" title="7.6. 安装桌面环境"></a>7.6. 安装桌面环境</h4><p><code>Linux</code> 下有很多著名的桌面环境如 <code>Xfce</code>、<code>KDE(Plasma)</code>、<code>Gnome</code>、<code>Unity</code>、<code>Deepin</code>等，它们的外观、操作、设计理念等各方面都有所不同给，在它们之间的比较与选择网上有很多的资料可以查询。</p><p>在这里我们选择笔者使用的 </p><p><code>Xfce</code> 和非常流行的 <code>KDE(Plasma)</code> 作为示范，当然你也可以把它们全部装上换着用，因为<code>Linux</code>的模块化，这样完全没有问题。</p><blockquote>    更多的桌面环境的安装指南请参考    https://wiki.archlinux.org/index.php/Desktop_environment#List_of_desktop_environments</blockquote><h5 id="安装-Xfce"><a href="#安装-Xfce" class="headerlink" title="安装 Xfce"></a>安装 <code>Xfce</code></h5><p>直接安装软件包组（包含了很多软件包）即可：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">sudo pacman -S xfce4 xfce4-goodies<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="安装-KDE-Plasma"><a href="#安装-KDE-Plasma" class="headerlink" title="安装 KDE(Plasma)"></a>安装 <code>KDE(Plasma)</code></h5><p>直接安装软件包组（包含了很多软件包）即可：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">sudo pacman -S plasma kde-applications<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="7-7-安装声音管理器"><a href="#7-7-安装声音管理器" class="headerlink" title="7.7. 安装声音管理器"></a>7.7. 安装声音管理器</h4><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">sudo pacman -S alsa-utils pulseaudio pulseaudio-alsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="7-8-安装蓝牙驱动"><a href="#7-8-安装蓝牙驱动" class="headerlink" title="7.8. 安装蓝牙驱动"></a>7.8. 安装蓝牙驱动</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">$ yay -S bluez bluez-utils blueman$ yay -S pulseaudio-bluetooth  # 要使用蓝牙耳机或音响的话需要安装 pulseaudio-bluetooth<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="7-9-Nvidia-独显驱动"><a href="#7-9-Nvidia-独显驱动" class="headerlink" title="7.9. Nvidia 独显驱动"></a>7.9. Nvidia 独显驱动</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">$ lspci  | grep -E "(VGA|3D)"      # 查看 NVIDIA 独显型号$ yay -S nvidia        # 安装合适显卡驱动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装好 <code>NVIDIA</code> 驱动后默认会生成 <code>/etc/X11/xorg.conf</code> 配置文件，如没有生成则执行以下命令：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">$ sudo nvidia-xconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最小配置如下：</p><p><em>注意：PCI 地址是 提到 NVIDIA 的输出行的前7个字符，看起来像 01:00.0，在 <code>xorg.conf</code> 中，需转换为 <code>#:#:#</code>，例如 <code>01:00.0</code> 应该写成 <code>1:0:0</code></em> </p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">Section "Module"    Load "modesetting"EndSectionSection "Device"    Identifier    "nvidia"    Driver    "nvidia"    BusID    "<BusID for NVIDIA device here>" # 修改为相应的 busID    Option    "AllowEmptyInitialConfiguration"EndSection<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sddm配置</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># sudo vim /usr/share/sddm/scripts/Xsetupxrandr --setprovideroutputsource modesetting NVIDIA-0xrandr --auto<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>重新启动</p><p>解决屏幕撕裂</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># sudo vim /etc/default/grub  # 在内核选项中添加参数GRUB_CMDLINE_LINUX_DEFAULT="nvidia-drm.modeset=1"# sudo vim /etc/mkinitcpio.conf    MODULES=(nouveau nvidia nvidia_modeset nvidia_uvm nvidia-drm)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行下面的命令</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">sudo mkinitcpio -p linux<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看 N 卡是否正常工作</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">$ nvidia-smi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="8-安装-oh-my-zsh"><a href="#8-安装-oh-my-zsh" class="headerlink" title="8. 安装 oh-my-zsh"></a>8. 安装 <code>oh-my-zsh</code></h3><p>确保 <code>git</code>、<code>wget</code>、<code>curl</code> 已经安装</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">sudo pacman -S git wget curl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装 <code>oh-my-zsh</code></p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># install oh-my-zsh via curl$ sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"# install oh-my-zsh via wget$ sh -c "$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下载插件</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">cd ~/.oh-my-zsh/pluginsgit clone git://github.com/zsh-users/zsh-autosuggestions.gitgit clone https://github.com/zsh-users/zsh-syntax-highlighting.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>下载好后在 <code>~/.zshrc</code> 文件中加入上述插件</p><p>找到 <code>plugins=git</code>， 改为如下（sudo 插件无需下载，效果为连续按两次 <kbd>esc</kbd> 键给命令加上 <code>sudo</code></p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">plugins=(        git        sudo        zsh-syntax-highlighting        zsh-autosuggestions)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使插件生效</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">source ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="9-安装中文字体和中文输入法"><a href="#9-安装中文字体和中文输入法" class="headerlink" title="9. 安装中文字体和中文输入法"></a>9. 安装中文字体和中文输入法</h3><h4 id="9-1-安装中文字体"><a href="#9-1-安装中文字体" class="headerlink" title="9.1 安装中文字体"></a>9.1 安装中文字体</h4><p>可以使用下面的命令进行安装，在安装后需要重启或者注销重新登陆</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">yay -S wqy-microhei wqy-microhei-lite wqy-zenhei wqy-bitmapfont<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他字体</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 安装 adobe 无衬线字体sudo pacman -S adobe-source-han-sans-otc-fonts# 安装 adobe 衬线字体sudo pacman -S adobe-source-han-serif-otc-fonts# 安装 noto 中文字体sudo pacman -S noto-fonts noto-fonts-cjk# 安装 noto emoji 表情包sudo pacman -S noto-fonts-emoji<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，adobe 字体可用于终端模拟器和文本编辑器等大部分桌面应用程序，而 noto 字体被指定为 icecat 浏览器的以来组建，故有 noto 中文来呈现网页内容。如果你使用 icecat 以外的浏览器，或许需要六七它对字体的要求。</p><h4 id="9-2-安装拼音输入法"><a href="#9-2-安装拼音输入法" class="headerlink" title="9.2 安装拼音输入法"></a>9.2 安装拼音输入法</h4><ol><li>安装输入法引擎 ibus-rime</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">sudo pacman -S ibus-rime<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装 rime, 会自动帮你安装 ibus 输入法模块。在其中你可以添加任意输入法，更改它们的设置，以及在应用程序中切换输入法。输入法的默认切换键是 <code>Super + Space</code>。 Super 就是传说中的 <kbd>Win</kbd>键。</p><ol><li>运行 ibus-setup 的初始程序</li></ol><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">ibus-setup<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它会启动后台程序并给你这条信息</p><pre><code>IBus has been started! If you cannot use IBus, please add below lines in $HOME/.bashrc, and relogin your desktop.（译：IBus已启动！如果您还不能用Ibus,请您先将以下的三行代码加到$HOME/.bashrc，再重新登录。)  export GTK_IM_MODULE=ibus  export XMODIFIERS=@im=ibus  export QT_IM_MODULE=ibus</code></pre><blockquote>    虽然 ibus 使用一个后台程序，但是它不是被 systemd 管理的那种后台程序，普通用户也可以运行，当你登陆时他会启动。<br>    但是，如果 ibus 尚未启动，先将那些 "export" 的代码复制到 $HOME/.xprofile, 并将这行代码添加到该文件： “ibus-daemon -x -d", 再重新登录。</blockquote><h3 id="10-安装谷歌浏览器"><a href="#10-安装谷歌浏览器" class="headerlink" title="10. 安装谷歌浏览器"></a>10. 安装谷歌浏览器</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 使用 AUR 帮助器安装 Google Chromeyay -S google-chrome    # installyay -Syu    ## update# 在没有 AUR 帮助器的情况下安装 Google Chrome# installgit clone https://aur.archlinux.org/google-chrome.gitcd google-chromemakepkg -si    # updategit pullmakepkg -si<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-安装-Typora"><a href="#11-安装-Typora" class="headerlink" title="11. 安装 Typora"></a>11. 安装 Typora</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">$ yay -S typora<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="12-安装-Steam"><a href="#12-安装-Steam" class="headerlink" title="12. 安装 Steam"></a>12. 安装 Steam</h3><p>由于 Steam 是32为程序且包含了一堆的32位库，所以64位 ArchLinux 要安装 Steam 的话首先要启用 Mulitilib</p><p>编辑 <code>/etc/pacman.conf</code> 文件， 将 <code>[mulitilib]</code> 字段的注释去掉。</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">[mulitilib]Include = /etc/pacman.d/mirrorlist<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后更新并安装 Steam</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">$ yay -Syu$ yay -S steam<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>issues:</p><p>如果打开　steam 后出现界面模糊，字体不清晰，可能是字体问题，我们需要安装 steam 支持的字体</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">$ yay -S steam-fonts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="13-安装网络分析器"><a href="#13-安装网络分析器" class="headerlink" title="13. 安装网络分析器"></a>13. 安装网络分析器</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">$ yay -S wireshark-qt$ sudo gpasswd -a $(whoami) wireshark // 不用 sudo  权限即可抓网卡<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="14-安装-docker"><a href="#14-安装-docker" class="headerlink" title="14. 安装 docker"></a>14. 安装 docker</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">$ yay -S docker$ sudo gpasswd -a $(whoami) docker // 不用 sudo 权限也可运行docker$ sudo systemctl restart docker$ sudo echo "&#123;"registry-mirrors":["https://hub-mirror.c.163.com"]&#125;" >> /etc/docker/daemon.json // 写入网易镜像源$ sudo systemctl enable docker // 开机自启 docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、桌面美化"><a href="#三、桌面美化" class="headerlink" title="三、桌面美化"></a>三、桌面美化</h2><h3 id="1-程序启动器：latte-dock"><a href="#1-程序启动器：latte-dock" class="headerlink" title="1. 程序启动器：latte-dock"></a>1. 程序启动器：latte-dock</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">$ yay -S latte-dock # 安装$ latte-dock # 启动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该启动器需要下在 Icons theme “<code>WhiteSur-dark</code>“。</p><p>在安装完成后，该程序就会自动启动，如果无法自动启动，可以手动编辑 <code>~/.xprofile</code> 文件，在新一行中输入</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">latte-dock &<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-壁纸插件"><a href="#2-壁纸插件" class="headerlink" title="2. 壁纸插件"></a>2. 壁纸插件</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">$ yay -S variety    # 安装$ variety    # 启动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在安装完成后，该程序就会自动启动，如果无法自动启动，可以手动编辑 <code>~/.xprofile</code> 文件，在新一行中输入</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">variety &<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-文件管理器"><a href="#3-文件管理器" class="headerlink" title="3. 文件管理器"></a>3. 文件管理器</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>唯美句子</title>
      <link href="posts/23383.html"/>
      <url>posts/23383.html</url>
      
        <content type="html"><![CDATA[<h1 id="唯美句子"><a href="#唯美句子" class="headerlink" title="唯美句子"></a>唯美句子</h1><h2 id="情"><a href="#情" class="headerlink" title="情"></a>情</h2><ol><li>倾一世温柔，只为暖那一场相逢，无论天涯海角，无论沧海桑田，只要你懂，我都会于默默里等你，花开花落两不弃，等你，从那辆银白色的火车上跳下来，微笑着，抱着我，连同我的温柔。</li><li>我和你的区别大概是，我手握刀刃把刀递给你，怕你受伤，你手持刀柄捅进我怀里，怕我纠缠。 </li><li>你能看见山，你能看见海，你能看见这个世界的一切，我就不一样，我目光比较短浅，只能看到你。</li><li>你知道什么是意外么？就是我从没想过会遇见你，但我遇见了，我从没想过会爱你，但我还是爱了。</li><li>想你不知所依，爱你至死不渝。</li><li>你说我的眼睛灿若星辰，那是因为你是星辰，而我的眼中只有你。</li><li>你是年少的喜欢——这句话倒过来也是你。</li><li>你犯罪了，把我的心偷走了。</li><li>把我的名字寄到你家户口本上几天能到货？</li><li>账都归你管，而你，归我管！</li><li>吟诵诗千卷，才发现最美的诗是你。</li><li>这一生，我只牵你的手，因为今生有你早已足够。</li><li>爱，要么不开始，要么一辈子。</li><li>你在的时候，你是一切；你不在的的时候，一切是你！</li><li>你是3，我是9，除了你，还是你。 </li><li>1 - 10 的意义，其 10 我喜欢你很久了，我想做你的依靠，请 8 你交给我，我绝对不会 7 负你，请把你 6 在我身边，5 发 4 绝对不会对你 3 心 2 意，我会 1 直喜欢你。</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>趁年华还在，趁笑靥仍美，趁阳光明媚闪耀，结束每一个一成不变的日子，去做一个更好的自己，拥有更好的生活。</li><li>永远不要丢掉别人对你的信任，因为别人信任你，是你在别人心目中存在的价值。否则，有一天当别人把你看清了，也就把你看轻了。诚信可赢天下，守信方得人心，且行，且珍惜！</li><li>百毒不侵的内心，往往会被依据简单的安慰大白，刀枪不入的伪装，常常在懂你人的面前彻底投降。做人不需人人都喜欢，只需坦荡荡。其实一辈子并不长，既然来了，就要活得漂亮</li><li>无需匆忙，该来的总会来，在对的时间，和对的人，因为对的理由。有时候，面对着身边的人；突然觉得说不出话，淡然并不是伪装出来的，而是一种沉淀。从某种意义上来说，人永远都不会老，老去的只是容颜，时间会让一颗灵魂，变得越来越动人。</li><li>人生，不要学着抱怨，怀着一颗坚毅而感恩的心，去拥抱每个挑战，每个人，其实都是可以的，只要我们用心一点，就那么一点点，生活也许少了许多抱怨或者悔恨。</li><li>人生有太多不舍，最后也都成了遗忘。综观人间世事，有得必有失，有失必有得，为了失去的物质而纠结，是不得偿失的事。我们应当学会调整心理，做一名超然物外的智者。</li><li>昨日再美好，终究压缩成今天的回忆，与其多心，不如少根筋；与其红了眼眶，不如笑着原谅。人生一世，糊涂难得，难得糊涂。活得太清楚，才是最大的不明白。人知足就会快乐，心简单就会幸福。</li><li>不要把一件事当做一件任务去做，答应了的事，就要做好，别让自己后悔。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux FHS</title>
      <link href="posts/26.html"/>
      <url>posts/26.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-FHS"><a href="#Linux-FHS" class="headerlink" title="Linux FHS"></a>Linux FHS</h1><p><em>FHS   &#40;Filesystem Hierachy Standard  &#41;</em> 依据文件系统使用的频繁与否与是否用户随意改动，而将目录定义成四种交互作用的形态：</p><ul><li><p><strong>可分享的</strong>：可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据，是能够分享给网络上其他主机挂载用的目录。</p></li><li><p><strong>不可分享的</strong>：自己机器上面运行的设备文件或者是程序有关的socket文件等，由于仅与自身机器有关，所以不适合分享给其他主机。</p></li><li><p><strong>不变的</strong>：有些数据是不会经常变动的，只会随着系统版本而变动。例如函数库、说明文件、系统管理员所管理的主机服务配置文件等。</p></li><li><p><strong>可变动的</strong>：经常改变的数据，例如登陆文件、用户文件等。</p></li></ul><h3 id><a href="#" class="headerlink" title="/"></a><code>/</code></h3><p>根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的，同时根目录也与开机、还原、系统修复等操作有关。</p><p>因此 FHS 标准建议： <strong>根目录<code>/</code></strong> 所在的分区应该越小越好，且应用程序所安装的软件最好不要与根目录放在同一个分区，保持根目录越小越好，如此不但性能较好，根目录所在的文件系统也不容易发生问题。</p><h3 id="bin"><a href="#bin" class="headerlink" title="/bin"></a><code>/bin</code></h3><p>bin 是 Binaries (二进制文件) 的缩写，这个目录存放着最经常使用的命令。</p><p> <code>/bin</code> 目录放置的命令可以在单用户维护模式下使用。 </p><h3 id="boot"><a href="#boot" class="headerlink" title="/boot"></a><code>/boot</code></h3><p>这个目录存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件和镜像文件。</p><h3 id="dev"><a href="#dev" class="headerlink" title="/dev"></a><code>/dev</code></h3><p>dev 是 Devices (设备) 的缩写，该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</p><h3 id="etc"><a href="#etc" class="headerlink" title="/etc"></a><code>/etc</code></h3><p>etc 是 Etcetera (等等) 的缩写，这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p><p>该目录下的文件只有 root 用户才能修改。</p><h3 id="home"><a href="#home" class="headerlink" title="/home"></a><code>/home</code></h3><p>用户的的家目录， 在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的帐号名命名的。</p><p> <code>~</code>代表当前用户的主文件夹。</p><h3 id="lib-、-lib64"><a href="#lib-、-lib64" class="headerlink" title="/lib 、 /lib64"></a><code>/lib</code> 、 <code>/lib64</code></h3><p>lib 是 Library (库) 的缩写，这个目录存放着系统最基本的动态链接共享库，其作用类似与 Windows 里的 DLL 文件，几乎所有的应用程序都要用到这些共享库。</p><p>其中 <code>/lib</code>是32位系统所调用的库，<code>/lib64</code>是64位系统调用的库。</p><p>你可以把函数库想象成是 “外挂”， 某些命令必须要有这些 ”外挂“ 才能顺利完成程序的执行。</p><h3 id="lost-found"><a href="#lost-found" class="headerlink" title="/lost+found"></a><code>/lost+found</code></h3><p>这个目录是使用标准 ext2/ext3 文件系统格式才会产生的一个目录，<strong>在文件系统发生错误时，一些丢失的片段会被放置到这个目录下</strong>。</p><p>每一个分区中，都会存在这个目录。</p><h3 id="media"><a href="#media" class="headerlink" title="/media"></a><code>/media</code></h3><p>media是 ”媒体“ 的英文，顾名思义， 这个 <code>/media</code> 下面放置的就是可删除的设备， 包括软盘、光盘、DVD等设备都暂时挂载于此。常见的文件名有<code>/media/floppy</code>, <code>/media/cdrom</code> 等。</p><h3 id="mnt"><a href="#mnt" class="headerlink" title="/mnt"></a><code>/mnt</code></h3><p>如果你想要暂时挂载某些额外的设备，一般建议你可以放置在这个目录中。在比较早的时候，这个目录的用途与<code>/media</code>相同，只是有了 <code>/media</code>之后，这个目录就被用来暂时挂载用了。</p><h3 id="opt"><a href="#opt" class="headerlink" title="/opt"></a><code>/opt</code></h3><p>opt 是 optional (可选) 的缩写，这个目录是用于安装第三方应用程序的，可以由用户自己指定安装位置。当需要卸载第三方应用程序是，可以直接删除安装目录，而不影响系统其他任何设置。</p><h3 id="proc"><a href="#proc" class="headerlink" title="/proc"></a><code>/proc</code></h3><p>proc 是 Processes (进程) 的缩写, <code>/proc</code> 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，他是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</p><p>这个目录的内容不在硬盘上，而是在内存里，我们也科技直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的 ping 命令，是别人无法 ping 你的机器。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="root"><a href="#root" class="headerlink" title="/root"></a><code>/root</code></h3><p>系统管理员（root）的家目录。之所以放在这里，是因为如果进入单用户维护模式而仅挂载根目录时，该目录就能够拥有root的主文件夹，所以我们会希望root的主文件夹与根目录放置在同一个分区中。</p><h3 id="run"><a href="#run" class="headerlink" title="/run"></a><code>/run</code></h3><p>是一个临时文件系统，存储系统启动以来的信息，当系统重启是，这个目录下的文件应该被删掉或清楚。如果你的系统上有 <code>/var/run/</code>目录，应该让它只想 <code>/run</code></p><h3 id="sbin"><a href="#sbin" class="headerlink" title="/sbin"></a><code>/sbin</code></h3><p>s 就是 Supper User 的意思，是 Superuser Binaries （超级用户的二进制文件）的缩写，这里存放的是系统管理员使用的系统管理程序。</p><p>Linux 有非常多的命令是用来设置系统环境的，这些命令只有 root 才能够利用来 “设置” 系统，其他用户最多只能用来 “查询” 而已。 放在 <code>/sbin</code> 下面的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的命令。</p><h3 id="selinux"><a href="#selinux" class="headerlink" title="/selinux"></a><code>/selinux</code></h3><p>这个目录是 Redhat/CentOS 所持有的目录， SELinux是一种安全机制，类似与 Windows的防火墙，但是这套机制比较复杂，这个目录就是存放 selinux 相关的文件的。</p><h3 id="srv"><a href="#srv" class="headerlink" title="/srv"></a><code>/srv</code></h3><p>srv 可以视为 “service” 的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。常见的服务例如 WWW、FTP等。举例来说 WWW 服务需要的网页数据就可以放置在 <code>/srv/www/</code> 里。</p><h3 id="sys"><a href="#sys" class="headerlink" title="/sys"></a><code>/sys</code></h3><p>这是 Linux 2.6 内核的一个很大的变化。 该目录下 2.5 内核中新出现的一个文件系统 sysfs。</p><p>sysfs 文件系统集成了下面3中文件系统的信息：</p><ul><li>针对进程信息的 proc 文件系统</li><li>针对设备的 devfs 文件系统</li><li>针对伪终端的 devpfs 文件系统</li></ul><p>该文件系统是内核设备数的一个直观反映， 当以个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中别创建。</p><h3 id="tmp"><a href="#tmp" class="headerlink" title="/tmp"></a><code>/tmp</code></h3><p>tmp 是 temporary (临时) 的缩写，这个目录使用来存放一些临时文件的。</p><h3 id="usr"><a href="#usr" class="headerlink" title="/usr"></a><code>/usr</code></h3><p>usr是 Unix Software Resource 的缩写，也就是 “UNIX 软件资源”目录，而不是用户的数据。</p><p>FHS建议所有软件开发者应该将他们的数据合理地分别放置到这个目录下的子目录，而不是自行新建该软件的独立目录。</p><ul><li><code>/usr/bin/</code>: 绝大部分的用户可使用的命令都放在这里</li><li><code>/usr/include/</code>: C/C++ 等程序语言的头文件（header) 与包含文件（include）放置出</li><li><code>/usr/lib/</code>: 包含各应用软件的函数库、目标文件以及一些不被一般用户惯用的执行文件或脚本</li><li><code>/usr/lib64/</code>:</li><li><code>/usr/local/</code>: 系统管理员在本机自行安装下载的软件建议安装到此目录</li><li><code>/usr/sbin/</code>: 非系统正常运行所需的系统命令</li><li><code>/usr/share</code>: 放置共享文件的地方</li><li><code>/usr/src/</code>: 一般源码建议放置到这里</li></ul><h3 id="var"><a href="#var" class="headerlink" title="/var"></a><code>/var</code></h3><p>该目录主要针对常态性可变动文件， 包括缓存（cache）、登陆文件（log file）以及某些软件运行所产生的文件，包括程序文件（lock file、run file），或者例如 MySQL数据库的文件等。</p><p>如果 <code>/usr</code> 是安装时会占用较大的硬盘容量的目录，那么 <code>/var</code>就是在系统运行后才会渐渐占用硬盘容量的目录。</p><ul><li><code>/var/cache/</code>: 应用程序本省运行过程中会产生的一些暂存文件</li><li><code>/var/lib</code>: 程序本身执行过程中，需要使用到的数据文件放置的目录</li><li><code>/var/lock/</code>: 目录下的文件资源一次只能被一个应用程序所使用</li><li><code>/var/log/</code>: 放置登陆文件的目录</li><li><code>/var/mail/</code>: 放置个人电子邮件信箱的目录</li><li><code>/var/run /</code>: 某些程序或服务启动后的 PID 目录</li><li><code>/var/spool</code>: 放置排队等待其他应用程序使用的数据</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux_Based</title>
      <link href="posts/38746.html"/>
      <url>posts/38746.html</url>
      
        <content type="html"><![CDATA[<!DOCTYPE html><html>    <head>        <title>Linux 基础</title>    </head>    <body>        <h2>计算机组成结构 </h2>        <p>计算机系统过由硬件系统和软件系统两大部分组成。美藉匈牙利科学家 冯 诺依曼（John von Neumann），奠定了现代计算机的基本机构：其特点如下：</p>        <ol>            <li>使用单一的处理部件来完成计算、存储以及通信的工作</li>            <li>存储单元是定长的线性组织.</li>            <li>存储空间的单元是直接寻址的。</li>            <li>使用低级机器语言，指令通过操作码来完成简单的操作。</li>            <li>对计算进行简单的顺序控制。</li>            <li>采用二进制形式表示数据和指令。</li>            <li>在执行程序和处理数据是必须将程序和数据从存储其装入主存储其中，然后才能使计算机</li>        </ol>        <h3>计算机指令</h3>        <h3>计算机硬件系统</h3>            <h3>CPU架构</h3>        <ol>            <li>精简指令集（Reduced Instruction Set Computer, RISC）</li>            <li>复杂指令集（Complex Instruction Set Computer, CISC）</li>        </ol>        <h3>容量单位</h3>        <table>            <tr>                <th>bit</th>                <th>Byte</th>                <th>kilo</th>                <th>Mega</th>                <th>Giga</th>                <th>Tera</th>                <th>Peta</th>                <th>Exa</th>                <th>Zetta</th>            </tr>            <tr>                <td>   </td>                <td>8bit</td>                <td>1024B</td>                <td>1024K</td>                <td>1024M</td>                <td>1024G</td>                <td>1024T</td>                <td>1024P</td>                <td>1024E</td>             </tr>        </table>        <h3>速度单位</h3>                <h3>CPU桥接器</h3>        <ol>            <li>北桥：负责连接速度较快的CPU、内存与显卡接口等元件。在目前的主流架构中，大多将北桥内存控制器整合到CPU封装中去了。</li>            <li>南桥：负责连接速度较慢的设备接口，包括硬盘、USB、网卡等等</li>        </ol>        <h3>CPU的工作频率：外频和倍频</h3>        <ul>            <li>外频：CPU与外部元件进行数据传输时的速度</li>            <li>倍频：CPU内部用来加速工作性嫩的一个倍数</li>        </ul>        <h2>Linux 分区</h2>        <h2>Linux Command</h2>        <h3>文件管理</h3>        <ol>            <li><code>touch</code></li>            <li><code>rm</code></li>            <li><code>cat</code></li>            <li></li>            <li></li>            <li></li>            <li></li>            <li></li>        </ol>    </body></html>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32_Linux_Develop</title>
      <link href="posts/17155.html"/>
      <url>posts/17155.html</url>
      
        <content type="html"><![CDATA[<!DOCTYPE html><html>    <head>        <title>STM32 Linux Develop</title>    </head>    <body>        <h2>一、安装交叉编译工具链</h2>        <h2>二、安装Jlink驱动</h2>        <h2>三、</h2>    </body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>uCOS-III</title>
      <link href="posts/60970.html"/>
      <url>posts/60970.html</url>
      
        <content type="html"><![CDATA[<h1 id="UCOS学习"><a href="#UCOS学习" class="headerlink" title="UCOS学习"></a>UCOS学习</h1><h2 id="裸机系统"><a href="#裸机系统" class="headerlink" title="裸机系统"></a>裸机系统</h2><p>裸机系统通常分为轮询系统和前后台系统。</p><h3 id="轮询系统"><a href="#轮询系统" class="headerlink" title="轮询系统"></a>轮询系统</h3><p>轮询系统即是在裸机编程的时候，先初始话相关的硬件，然后让主程序在一个死循环里面不断循环，顺序的做各种事情。</p><p>适合顺序执行的功能代码，当有外部事件驱动该时，实时性就会降低。</p><h3 id="前后台系统"><a href="#前后台系统" class="headerlink" title="前后台系统"></a>前后台系统</h3><p>相比轮询系统，前后台系统实在轮询系统的基础上加入了中断。外部事件的响应在中断里面完成，事件的处理还是回到轮询系统中完成，中断在这里我们称为前台，main函数里面的无限循环我们称为后台。</p><p>使用前后台系统，可以大大提高程序的实时响应能力。</p><h2 id="多任务系统"><a href="#多任务系统" class="headerlink" title="多任务系统"></a>多任务系统</h2><p>相比于前后台系统，多任务系统的事件响应也是在中断中完成的，但是事件的处理实在任务中完成的。在多任务系统中，任务跟中断一样，也具有优先级，优先级高的任务会被优先执行。当一个紧急的事件在中断被标记之后，如果事件对应的任务的优先级足够高，就会立马得到响应。相比前后台系统，多任务系统的实时性又被提高了。</p><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><p>凡是与CPU类型相关的数据类型统一在<code>cpu.h</code>中定义</p><p>与操作系统相关的数据类型则在 <code>ostype.h</code>中定义。</p><p><strong>uC/OS-III中的命名规则：</strong>以<code>OS</code>开头，表示这是一个外部函数，可以又用户调用；以<code>OS_</code>开头的函数表示内部函数，只能在uC/OS-III内部使用。  紧接着是文件名，表示该函数放在哪个文件中，最后是函数功能名称。</p><h2 id="任务定义与任务切换"><a href="#任务定义与任务切换" class="headerlink" title="任务定义与任务切换"></a>任务定义与任务切换</h2><h3 id="任务定义"><a href="#任务定义" class="headerlink" title="任务定义"></a>任务定义</h3><h3 id="1-定义任务优先级"><a href="#1-定义任务优先级" class="headerlink" title="1.定义任务优先级"></a>1.定义任务优先级</h3><h4 id="2-定义任务栈"><a href="#2-定义任务栈" class="headerlink" title="2.定义任务栈"></a>2.定义任务栈</h4><pre class="line-numbers language-lang-c"><code class="language-lang-c">#define TASK_STK_SIZE 128     // 在uC/OS-III中，空闲任务的栈大小最小应该大于128CPU_STK TaskStk[TASK_STK_SIZE];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-定义任务控制块"><a href="#3-定义任务控制块" class="headerlink" title="3. 定义任务控制块"></a>3. 定义任务控制块</h4><pre class="line-numbers language-lang-c"><code class="language-lang-c">OS_TCB TaskTCB;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-定义任务函数"><a href="#4-定义任务函数" class="headerlink" title="4.定义任务函数"></a>4.定义任务函数</h4><pre class="line-numbers language-lang-c"><code class="language-lang-c">void Task(void *p_arg)&#123;    while(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>OSTaskCreate()</code>，<code>OSTaskStkInit()</code>，<code>OSInit()</code>，<code>OSStart()</code></p><h2 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h2><h2 id="空闲任务"><a href="#空闲任务" class="headerlink" title="空闲任务"></a>空闲任务</h2><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><h2 id="临界段"><a href="#临界段" class="headerlink" title="临界段"></a>临界段</h2><h2 id="uCOS-III移植"><a href="#uCOS-III移植" class="headerlink" title="uCOS-III移植"></a>uCOS-III移植</h2><h3 id="1-准备STM32裸机工程模板"><a href="#1-准备STM32裸机工程模板" class="headerlink" title="1.准备STM32裸机工程模板"></a>1.准备STM32裸机工程模板</h3><h3 id="2-获取uCOS-III源码"><a href="#2-获取uCOS-III源码" class="headerlink" title="2.获取uCOS-III源码"></a>2.获取uCOS-III源码</h3><p>打开Micrium 公司<a href="www.micrium.com">官方网站</a>，选择 Downloads 选项卡进入下载页面，在这里针对不同的架构，不同的MCU，有不同的项目评估版源码，我们移植uCOS-III，就是将下载的源码移植到我们准备的裸机工程里。</p><p>下载的时候我们要选择与我们开发板最为接近的版本。</p><p>如： STM32F103系列开发板，我们选择 STM32F107 评估板的项目源码</p><p><img src="/posts/60970/Download-Template-project.png" alt="Download Template project"></p><h4 id="2-1-uC-OS-III-源码文件介绍（STM32F107）"><a href="#2-1-uC-OS-III-源码文件介绍（STM32F107）" class="headerlink" title="2.1 uC/OS-III 源码文件介绍（STM32F107）"></a>2.1 uC/OS-III 源码文件介绍（STM32F107）</h4><p><img src="/posts/60970/Code-Folder.png" alt="Code Folder"></p><ul><li><strong>EvalBoards</strong> 文件夹中包含了，与板子相关的文件，配置文件，以及<code>bsp</code>文件</li><li><strong>uC-CPU</strong> ：包含和CPU紧密相关的文件，里面的一些文件很重要，都是我们需要使用的。在<strong>ARM-Cortex-M3</strong>文件夹下，有GNU、IAR、RealView等文件夹，其中该包括<code>cpu-c.c</code>等重要文件，我们使用的开发环境是MDK（keil），所以选择 RealView 文件夹下的源码文件。</li><li><strong>uC-LIB</strong>：可以选择地使用 Micrium 公司提供的官方库，诸如字符串操作、内存操作等接口，一般用于代替标准库中的一些函数，使得在嵌入式中应用更加方便、安全。</li><li><strong>uCOS-III</strong>：该文件夹下有两个文件夹：<strong>Ports</strong> 和 <strong>Source</strong> <ul><li><strong>Ports</strong> 文件夹中的文件是与处理器架构相关的代码，即RTOS硬件接口层；在该文件下也有GNU、IAR、RealView等文件夹，在不同的开发环境下，需要选择不同的文件。</li><li><strong>Source</strong>文件夹中存储的是 uC/OS的源码文件，他们是 uC/OS 核心文件，是非常重要的，在移植时必须将这些文件添加到工程中。</li></ul></li></ul><h3 id="3-移植到STM32裸机工程"><a href="#3-移植到STM32裸机工程" class="headerlink" title="3.移植到STM32裸机工程"></a>3.移植到STM32裸机工程</h3><h4 id="3-1-创建文件夹"><a href="#3-1-创建文件夹" class="headerlink" title="3.1 创建文件夹"></a>3.1 创建文件夹</h4><pre><code>UCOSIII├── uCOS-BSP    # 放置 EvalBoards 目录中的 bsp文件├── uCOS-CONFIG    # 放置 EvalBoards 目录中的 配置文件├── uCOS-CPU     # 放置 uC-CPU 目录中的文件├── uCOS-III    # 放置 uCOS-III 目录中的文件|   ├── Ports|   └── Source└── uCOS-LIB    # 放置 uC-LIB 目录中的文件</code></pre><h4 id="3-2-在工程中添加文件分组并将在根目录创建的文件夹中的文件添加进来"><a href="#3-2-在工程中添加文件分组并将在根目录创建的文件夹中的文件添加进来" class="headerlink" title="3.2 在工程中添加文件分组并将在根目录创建的文件夹中的文件添加进来"></a>3.2 在工程中添加文件分组并将在根目录创建的文件夹中的文件添加进来</h4><p><img src="/posts/60970/Add-Group.png" alt="Add Group"></p><h4 id="3-3-添加头文件目录"><a href="#3-3-添加头文件目录" class="headerlink" title="3.3 添加头文件目录"></a>3.3 添加头文件目录</h4><p><img src="/posts/60970/Add-Head-File-Folder.png" alt="Add Head File Folder"></p><h4 id="3-4-修改工程文件"><a href="#3-4-修改工程文件" class="headerlink" title="3.4 修改工程文件"></a>3.4 修改工程文件</h4><h5 id="3-4-1-修改启动文件"><a href="#3-4-1-修改启动文件" class="headerlink" title="3.4.1 修改启动文件"></a>3.4.1 修改启动文件</h5><p><img src="/posts/60970/Modify-Startup-File_1.png" alt="Modify Startup File 1"></p><p><img src="/posts/60970/Modify-Startup-File_2.png" alt="Modify Startup File 2"></p><p>并将<code>stm32f10x_it.c</code>文件中的 <code>PendSV_Handler</code>函数和<code>SysTick_Handler</code>函数注释。</p><h4 id="3-4-2-FPU运算"><a href="#3-4-2-FPU运算" class="headerlink" title="3.4.2  FPU运算"></a>3.4.2  FPU运算</h4><p>如果MCU支持 FPU运算，需要添加如下代码，然后在 Option -&gt; Target-&gt; Floating Point Hardware 中选择启用浮点运算。。</p><p><img src="/posts/60970/image-20200916163024182.png" alt="image-20200916163024182"></p><h4 id="3-4-3-修改bsp-c和bsp-h文件"><a href="#3-4-3-修改bsp-c和bsp-h文件" class="headerlink" title="3.4.3 修改bsp.c和bsp.h文件"></a>3.4.3 修改<code>bsp.c</code>和<code>bsp.h</code>文件</h4><p>根据个人习惯和个人需要，可以进行修改，除了部分时钟相关的需要保留外，其他的部分都可以自行删改；修改完成后，我们可以编译一下，看会不会报错。</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">#define  BSP_MODULE#include <bsp.h>CPU_INT32U  BSP_CPU_ClkFreq_MHz;#define  DWT_CR      *(CPU_REG32 *)0xE0001000#define  DWT_CYCCNT  *(CPU_REG32 *)0xE0001004#define  DEM_CR      *(CPU_REG32 *)0xE000EDFC#define  DBGMCU_CR   *(CPU_REG32 *)0xE0042004#define  DBGMCU_CR_TRACE_IOEN_MASK       0x10#define  DBGMCU_CR_TRACE_MODE_ASYNC      0x00#define  DBGMCU_CR_TRACE_MODE_SYNC_01    0x40#define  DBGMCU_CR_TRACE_MODE_SYNC_02    0x80#define  DBGMCU_CR_TRACE_MODE_SYNC_04    0xC0#define  DBGMCU_CR_TRACE_MODE_MASK       0xC0#define  DEM_CR_TRCENA                   (1 << 24)#define  DWT_CR_CYCCNTENA                (1 <<  0)void  BSP_Init (void)&#123;    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);    BSP_LED_Init();    GPIO_ResetBits(LED_PORT,LED_PIN);&#125;CPU_INT32U  BSP_CPU_ClkFreq (void)&#123;    RCC_ClocksTypeDef  rcc_clocks;    RCC_GetClocksFreq(&rcc_clocks);    return ((CPU_INT32U)rcc_clocks.HCLK_Frequency);&#125;#if ((APP_CFG_PROBE_OS_PLUGIN_EN == DEF_ENABLED) && \     (OS_PROBE_HOOKS_EN          == 1))void  OSProbe_TmrInit (void)&#123;&#125;#endif#if ((APP_CFG_PROBE_OS_PLUGIN_EN == DEF_ENABLED) && \     (OS_PROBE_HOOKS_EN          == 1))CPU_INT32U  OSProbe_TmrRd (void)&#123;    return ((CPU_INT32U)DWT_CYCCNT);&#125;#endif#if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)void  CPU_TS_TmrInit (void)&#123;    CPU_INT32U  cpu_clk_freq_hz;    DEM_CR         |= (CPU_INT32U)DEM_CR_TRCENA;                /* Enable Cortex-M3's DWT CYCCNT reg.                   */    DWT_CYCCNT      = (CPU_INT32U)0u;    DWT_CR         |= (CPU_INT32U)DWT_CR_CYCCNTENA;    cpu_clk_freq_hz = BSP_CPU_ClkFreq();    CPU_TS_TmrFreqSet(cpu_clk_freq_hz);&#125;#endif#if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)CPU_TS_TMR  CPU_TS_TmrRd (void)&#123;    return ((CPU_TS_TMR)DWT_CYCCNT);&#125;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-4-按需配置最适工程"><a href="#3-4-4-按需配置最适工程" class="headerlink" title="3.4.4 按需配置最适工程"></a>3.4.4 按需配置最适工程</h4><p>完成前面的修改后，此时工程是可以使用了的，但这并不是最适合的工程模板，我们需要进行配置，对 uCOS 系统进行裁剪。</p><div class="table-container"><table><thead><tr><th>文件名</th><th>描述</th></tr></thead><tbody><tr><td>os_cfg.h</td><td>os_cfg.h 文件是系统的配置文件，主要是让用户自己配置一些系统默认的功能，用户可以选择某些或者全部的功能，比如消息队列、信号量、互斥量、事件标志位等，系统默认全部使用，如果用户不需要的话，则可以直接关闭，在对应的宏定义中设置为0即可，这样子就不会占用系统的 SRAM，以节省系统资源。</td></tr><tr><td>cpu_cfg.h</td><td>cpu_cfg.h 文件主要是配置 CPU相关的一些宏定义，我们可以选择对不同的 CPU 进行配置，当然，如果我们没有对CPU很熟悉的话，就直接忽略这个文件即可，在这里我们只需要注意关于时间戳与前导零指令相关的内容，我们使用的 CPU 是32位的CPU，那么时间戳我们使用 32位 的变量即可，而且 STM32支持前导零指令，可以使用它让系统进行寻找最高的有相机任务更加快捷</td></tr><tr><td>os_cfg_app.h</td><td>os_cfg_app.h 是系统应用配置的头文件，简单来说就是系统默认的任务配置，如任务的优先级、堆栈大小等基本信息，但是有两个任务是必须开启的，一个是空闲任务，另一个是时钟节拍任务，这两个是让系统正常运行的最基本任务，而其他任务我们自己按需配置即可。</td></tr></tbody></table></div><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>在定义任务堆栈时，在前面加上 <code>__aligned(8)</code>，使堆栈按8字节对齐，这样在打印输出浮点数时，才能正确打印，也能减少很多未知 bug 的出现 </li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>npm 命令详解</title>
      <link href="posts/34849.html"/>
      <url>posts/34849.html</url>
      
        <content type="html"><![CDATA[<h2 id="npm-install"><a href="#npm-install" class="headerlink" title="npm install"></a>npm install</h2><ul><li><p>-S，-save 安装包信息将加到 dependencies  (生产阶段的依赖)</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">  npm install --save   npm install -S<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>-D，—save-dev 安装包信息加载到 devDependencied (开发阶段的依赖)</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">npm install --save-devnpm install -D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>-O, —save-optional 安装包信息将加入到 optionalDependencies  (可选阶段的依赖)</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">  npm install jquery --save-optional   npm install jquery -O  # 以安装 jquery 为例， package.jso 的文件中 optionDependencies 字段有以下大妈  "optionalDependencies":&#123;       "jquery":"^3.9.1"  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>-E，—save-exact 精确安装指定模块版本</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">  npm install jquery --save-exact  npm install jquery -E  # 如果输入命令为   npm install jquery -ES  # 留意 package.json 文件的 dependencies 字段，可以看到版本好中的 ^ 消失了  "dependencies": &#123;      "jquery": "3.2.1"  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>模块依赖都没写入了package.json文件后，他人打开项目的根目录（羡慕开源、内部团队合作），使用<code>npm install</code>命令可以根据 dependencies 配置安装所有的依赖包</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">  npm isntall # 输入该命令后， package.json 的 devDependencies 字段里的插件会被自动安装到 node_modules 下<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>npm uninstall</code>卸载模块</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">  npm uninstall jquery --save-optional  # 卸载可选阶段里的jquery<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>npm 目前支持以下几种依赖包的管理：</p><ul><li><p><strong>depedencies</strong> : 指定应用依赖的外部包，这些依赖时应用正常发布后正常执行所需要的，但不包含测试时和本地打包时所使用的包。</p></li><li><p><strong>devDependencies</strong>：它里面的包只用于开发环境，不用于生产环境，这些包通常时单元测试或者打包工具等，例如 gulp,grunt,webpack,moca,coffee 等</p></li><li><p><strong>peerDependencies</strong>：同等依赖，或者叫同伴依赖，用于指定当前包（也就是你写的包）兼容的宿主版本。如何理解呢？试想以下，我们编写一个guip的插件，而gulp却有多个主版本，我们只想兼容最新的版本，此时就可以用同等依赖（peerDependencies）来指定：</p><pre class="line-numbers language-lang-Json"><code class="language-lang-Json">&#123;  "name": "gulp-mu-plugin",  "version": "0.0.1",  "peerDependencies",  &#123;      "gulp": "3.x"  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当别人使用我们的插件时，peerDependencies就会明确的告诉使用方，你需要安装该插件的那个宿主版本。通常情况下，我们会在一个项目里使用一个宿主（比如gulp）的很多插件，如果相互之间存在宿主不兼容，在执行 npm install 时， cli 会抛出错误信息来告诉我们，比如：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">npm ERR! peerinvalid The package gulp does not statisfy its siblings' peerDependencies requirements!npm ERR! peerinvalid Peer gulp-cli-config@0.1.3 wants gulp@-3.1.9npm ERR! peerinvalid Peer gulp-cli-users@0.1.4 wants gulp@-2.3.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>运行命令 npm install gulp-my-plugin —save-dev 来安装我们的插件，我们来看下依赖图谱：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">├── gulp-my-plugin@0.0.1└── gulp@3.9.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>optionalDependencies</strong>：可选依赖，如果有一些依赖包即使安装失败，项目仍然能够运行或者希望 npm 继续运行，就可以使用 optionDependencies。另外 optionalDependencies 会覆盖 dependencies中的同名依赖包，所以不要在两个地方都写。</p></li><li><p><strong>bundledDependencies / bundleDependencies</strong>:  打包依赖， bundledDependencies是一个包含依赖包名的数组，在发布时会将这个对象中的包打包到最终的发布包里。</p></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_learning</title>
      <link href="posts/62111.html"/>
      <url>posts/62111.html</url>
      
        <content type="html"><![CDATA[<h2 id="Linxu系统启动过程"><a href="#Linxu系统启动过程" class="headerlink" title="Linxu系统启动过程"></a>Linxu系统启动过程</h2><ol><li>内核引导</li><li>运行 init</li><li>系统初始化</li><li>建立终端</li><li>用户登陆系统</li></ol><h2 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h2><p>  <code>ls</code>、<code>cd</code>、<code>mkdir</code>、<code>rmdir</code>、<code>rm</code></p><p>数据恢复工具<code>extundelete</code></p><p>增删改查</p><p>重定向 <code>&gt;&gt;</code>、<code>&lt;&lt;</code>、</p><p><code>touch</code>、<code>stat</code>、<code>cat</code>、<code>more</code>、<code>less</code>、<code>head</code>、<code>tail</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yaml</title>
      <link href="posts/65391.html"/>
      <url>posts/65391.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>YAML语言（发音 /ˈjæməl/）的设计目标，就是方便人类读写。它实质上是通用的数据串行化格式。</p><p>他的基本语法规则如下。</p><blockquote>    <ul>        <li>大小写敏感</li>        <li>使用缩进表示层级关系</li>        <li>缩进时不允许使用Tab键，只允许使用空格</li>        <li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li>    </ul></blockquote><p><code>#</code>表示注释，从这个字符开始，一直到行尾都会被解析器忽略。</p><p>YAML支持的数据结构有三种：</p><ul>    <li>对象：键值对的集合，又称为映射(mapping)/哈希(hashes)/字典(dictionary)</li>    <li>数组：一组按次序排列的值，又称为序列(sequence)/列表(list)</li>    <li>纯量(scalars):单个的、不可再分的值</li></ul><h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><h3 id="1-对象"><a href="#1-对象" class="headerlink" title="1. 对象"></a>1. 对象</h3><p>    对象的一组键值对，使用冒号结构表示</p><pre class="line-numbers language-lang-yaml"><code class="language-lang-yaml"># yamlanimal: pets# JavaScript&#123; animal: 'pets'&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Yaml也允许另一种写法，将所有键值对写成一个行内对象。</p><pre class="line-numbers language-lang-yaml"><code class="language-lang-yaml"># yamlhash: &#123; name: Steve, foo: bar &#125;# JavaScript&#123; hash: &#123; name: 'Steve', foo: 'bar' &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-数组"><a href="#2-数组" class="headerlink" title="2. 数组"></a>2. 数组</h3><p>一组连词线开头的行，构成一个数组。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yaml- Cat- Dog- Goldfish# JavaScript[ 'Cat', 'Dog', 'Goldfish' ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据结构的自成员是一个数组，则可以在该项下面缩进一个空格。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yaml- - Cat - Dog - Goldfish# JavaScript[ ['Cat', 'Dog', 'Goldfish'] ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组也可以采用行内表示法：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yamlanimal: [Cat, DOg]# JavaScript&#123; animal: ['Cat', 'Dog']&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-复合结构"><a href="#3-复合结构" class="headerlink" title="3. 复合结构"></a>3. 复合结构</h3><p>对象和数组可以结合使用，形成复合机构。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yamllanguages: - Ruby - Perl - Pythonwebsites: YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org# JavaScript&#123;   languages: ['Ruby', 'Perl', 'Python'] ,  websites:  &#123;    YAML: 'yaml.org',    Ruby: 'ruby-lang.org'    Python: 'python.org',    Perl: 'use.perl.org'  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-纯量"><a href="#4-纯量" class="headerlink" title="4. 纯量"></a>4. 纯量</h3><p>纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯良</p><ul>    <li>字符串</li>    <li>布尔值</li>    <li>整数</li>    <li>浮点数</li>    <li>Null</li>    <li>时间</li>    <li>日期</li></ul><p>数值直接以字面量的形式表示：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yamlnumber: 12.30# JavaScript&#123; number: 12.30 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>布尔值用 <code>true</code> 和 <code>false</code> 表示</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yamlisSet: true# JavaScript&#123; isSet: true &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>null</code> 用 <code>~</code>表示：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yamlparent: ~# JavaScript&#123; parent: null &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间采用  ISO8601  格式</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yamliso8601: 2001-12-14t19:29:20.10-05:00# JavaScript&#123; iso8601: new Date('2001-12-14-19:29:20.10-05:00')&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>日期采用复合 iso8601 格式的年、月、日表示：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yamldate： 1999-09-21# JavaScript&#123; date: new Date('1976-0731')&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Yaml 允许使用两个感叹号强制转换数据类型</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yamle: !!str 123f: !!str true# JavaScript&#123; e: '123', f: 'true'&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5. 字符串"></a>5. 字符串</h3><p>字符串时最常见，也是最复杂的一种数据类型。</p><p>字符串默认不适用引号表示。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yamlstr: 这是一行字符串# JavaScript&#123; str: '这是一行字符串' &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果字符串之中包含空格或特殊字符，需要放在引号之中。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yamlstr: '内容： 字符串'# JavaScript&#123; str: '内容：字符串' &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>单引号和双引号都可以使用，双引号不会对特殊字符转义：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yamls1: '内容\n字符串's2: "内容\n字符串"# JavaScript&#123; s1: '内容\\n字符串'， s2: '内容\n字符串' &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>单引号之中如果还有单引号，必须连续使用两个单引号转义。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yamlstr: 'labor''s day'# JavaScriptstr: 'labor\'s day'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转换为空格。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yamlstr: 这是一段 多行 字符串# JavaScript&#123; str: '这是一段 多行 字符串' &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多行字符串可以使用 <code>|</code> 保留换行符，也可以使用 <code>&gt;</code>折叠换行。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yamlthis: | Foo Barthat: > Foo Bar# JavaScript&#123; this: 'Foo\nBar\n', that: 'Foo Bar\n' &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>+</code>表示保留文字块末尾的换行符， <code>-</code>表示删除字符串末尾的换行。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yamls1: | Foos2: |+ Foos3: |- Foo# JavaScript&#123; s1: 'Foo\n', s2: 'Foo\n\n\n', s3: 'Foo' &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符串之中可以插入HTML标记。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yamlmessage: |  <p style="color:red">    段落  </p># JavaScript&#123; message: '\n<p style="color:red">\n 段落\n</p>\n' &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-引用"><a href="#6-引用" class="headerlink" title="6. 引用"></a>6. 引用</h3><p>锚点 <code>&amp;</code>和别名<code>*</code>，可以用来引用。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yamldefault: &default  adapter: postgres  host:    localhostdevelopment:  database: myapp_development  <<: *default test:   database: myapp_test   <<: *defaults# JavaScriptdefaults:  adapter: postgres  host:    localhostdevelopment:  database: myapp_development  adapter: postgres  host:    localhosttest:  database: myapp_test  adapter: postgres  host: localhost<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>&amp;</code>用来建立锚点(<code>defaults</code>),<code>&lt;&lt;</code>表示合并到当前数据，<code>*</code>用来引用锚点。</p><p>下面是另一个例子</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yaml- &showell Steve- Clark- Brian- Oren- *showell# JavaScript['Steve', 'Clark', 'Brian', 'Oren', 'Steven']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Yaml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo</title>
      <link href="posts/37733.html"/>
      <url>posts/37733.html</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><p>Hexo 是一个快速、简介且高效的博客框架。Hexo使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><p>安装Hexo我们要先安装一些软件</p><ul><li><a href="http://nodejs.org/">Node.js</a>（Node.js  版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本）</li><li><a href="http://git-scm.com/">Git</a></li></ul><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><ul><li>windows: 通过 nvs 或 nvm 安装</li><li>Mac： 使用HomeBrew 或 MacPorts 安装</li><li>Linux： 使用相应的软件包管理器进行安装，可以参考Node.js提供的 <a href="https://nodejs.org/en/download/package-manager/">指导</a> </li></ul><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><ul><li>Windows: 下载并安装 <a href="https://git-scm.com/download/win">git</a>.</li><li>Mac: 使用HomeBrew ，MacPorts或者下载安装程序 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a></li><li>Linux： 使用软件包管理器进行安装<ul><li>Ubuntu, Debian:  <code>sudo apt-get install git-core</code></li><li>Fedora, Red Hat, CentOs:  <code>sudo yum install git-core</code></li></ul></li></ul><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ npm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="进阶安装和使用"><a href="#进阶安装和使用" class="headerlink" title="进阶安装和使用"></a>进阶安装和使用</h4><p>对于熟悉 npm 的进阶用户，可以仅局部安装 <code>hexo</code> 包</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ npm install hexo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装以后，可以使用以下两种方式执行<code>Hexo</code>:</p><ol><li><p><code>npx hexo &lt;command&gt;</code></p></li><li><p>将 Hexo 所在目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code>:</p></li></ol><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">echo 'PATH="$PATH:./node_modules/.bin"' >> ~/.profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    </p><h3 id="Node-js-版本限制"><a href="#Node-js-版本限制" class="headerlink" title="Node.js 版本限制"></a>Node.js 版本限制</h3><p>官网中建议永远安装最新版本的 Hexo ，以及推荐的 Node.js  版本。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Hexo版本</th><th style="text-align:center">最低兼容Node.js版本</th></tr></thead><tbody><tr><td style="text-align:center">5.0+</td><td style="text-align:center">10.13.0</td></tr><tr><td style="text-align:center">4.1～4.2</td><td style="text-align:center">8.10</td></tr><tr><td style="text-align:center">4.0</td><td style="text-align:center">8.6</td></tr><tr><td style="text-align:center">3.3～3.9</td><td style="text-align:center">6.9</td></tr><tr><td style="text-align:center">3.2～3.3</td><td style="text-align:center">0.12</td></tr><tr><td style="text-align:center">3.0～3.1</td><td style="text-align:center">0.1 or iojs</td></tr><tr><td style="text-align:center">0.0.1~2.8</td><td style="text-align:center">0.10</td></tr></tbody></table></div><h2 id="Hexo建站"><a href="#Hexo建站" class="headerlink" title="Hexo建站"></a>Hexo建站</h2><p>Hexo安装完成后，执行系列命令，Hexo将会在指定文件家中新建所需要的文件。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo init <folder>$ cd <folder>$ npm install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>新建完成后，指定文件夹的目录如下：</p><pre><code>.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>网站的配置信息，可以在这个文件中配置大部分的参数。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>应用程序的信息。其中 <a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除</p><pre><code>package.json&#123;  &quot;name&quot;: &quot;hexo-site&quot;,  &quot;version&quot;: &quot;0.0.0&quot;,  &quot;private&quot;: true,  &quot;hexo&quot;: &#123;    &quot;version&quot;: &quot;&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;hexo&quot;: &quot;^3.8.0&quot;,    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,    &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,    &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,    &quot;hexo-server&quot;: &quot;^0.3.3&quot;  &#125;&#125;</code></pre><h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p>模板文件，当你新建文章时，Hexo会根据scaffold来建立文件。</p><p>Hexo的模板时指在新建的文章文件中默认填充的内容。例如，你修改<code>scaffold/post.md</code>中的Front-matter内容，那么每次新建一篇文章时，都会包含这个修改。</p><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹，这是存放用户资源的地方。除<code>_posts</code>文件夹之外，开头命名为<code>_</code>（下划线）的文件或文件夹和隐藏的文件将会被忽略。 Markdown 和 HTML 文件会被解析并放到 <code>public</code>文件夹，而其他文件会被拷贝过去。</p><h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p>主题文件夹。Hexo会根据主题来生成静态页面。</p><h2 id="Hexo-配置"><a href="#Hexo-配置" class="headerlink" title="Hexo 配置"></a>Hexo 配置</h2><p>_config.yml中的配置</p><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>title</code></td><td>网站标题</td></tr><tr><td style="text-align:center"><code>subtitle</code></td><td>网站副标题</td></tr><tr><td style="text-align:center"><code>description</code></td><td>网站描述，主要用于SEO，告诉搜索引擎一个关于你站点的简单描述，通常建议在其中包含网站的关键词。</td></tr><tr><td style="text-align:center"><code>keywords</code></td><td>网站的关键词，支持多个关键词</td></tr><tr><td style="text-align:center"><code>author</code></td><td>你的名字，用于主题显示文章的作者。</td></tr><tr><td style="text-align:center"><code>language</code></td><td>网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code></td></tr><tr><td style="text-align:center"><code>timezon</code></td><td>网站时区，Hexo默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如<code>America/New_York</code>,<code>Japan</code>和<code>UTC</code>。一般的，对于中国大陆地区可以使用<code>Asiz/Shanghai</code>。</td></tr></tbody></table></div><h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h3><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th>描述</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td style="text-align:center"><code>url</code></td><td>网址</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>root</code></td><td>网站根目录</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>permalink</code></td><td>文章的永久链接格式</td><td style="text-align:center"><code>`:year/:month/:day/:title/</code></td></tr><tr><td style="text-align:center"><code>permalink_defaults</code></td><td>永久链接中各部分的默认值</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>pretty_urls</code></td><td>改写<code>permalink</code>的值来美化URL</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>pretty_urls.trailing_index</code></td><td>是否在永久链接中保留尾部的<code>index.html</code>，设置为<code>false</code>时去除</td><td style="text-align:center"><code>true</code></td></tr><tr><td style="text-align:center"><code>pretty_urls.trailing_html</code></td><td>是否在永久链接中保留尾部的<code>.html</code>，设置为<code>false</code>时去除（对尾部的<code>index.html</code>无效）</td><td style="text-align:center"><code>true</code></td></tr></tbody></table></div><blockquote><p><strong>网站存放在子目录</strong></p><p>如果你的网站存放在子目录，例如<code>http://yoursite.com/blog</code>，则请将你的<code>url</code>设为<code>http://yoursite.com/blog</code>，并把<code>root</code>设为<code>/blog/</code>。</p></blockquote><pre class="line-numbers language-lang-yaml"><code class="language-lang-yaml"># 如果一个页面的永久链接是 http://example.com/foo/bar/index.htmlpretty_urls:    trailing_index:false# 此时页面的永久链接会变为 `http://example.com/foo/bar/`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td style="text-align:center"><code>source_dir</code></td><td style="text-align:center">资源文件夹，这个文件夹用来存放内容</td><td style="text-align:center"><code>source</code></td></tr><tr><td style="text-align:center"><code>public_dir</code></td><td style="text-align:center">公共文件夹，这个文件夹用于存放生成的站点文件</td><td style="text-align:center"><code>public</code></td></tr><tr><td style="text-align:center"><code>tag_dir</code></td><td style="text-align:center">标签文件夹</td><td style="text-align:center"><code>tags</code></td></tr><tr><td style="text-align:center"><code>archive</code></td><td style="text-align:center">归档文件夹</td><td style="text-align:center"><code>archives</code></td></tr><tr><td style="text-align:center"><code>category_dir</code></td><td style="text-align:center">分类文件夹</td><td style="text-align:center"><code>categories</code></td></tr><tr><td style="text-align:center"><code>code_dir</code></td><td style="text-align:center">Include code 文件夹，<code>source_dir</code>下的子目录</td><td style="text-align:center"><code>downloads/code</code></td></tr><tr><td style="text-align:center"><code>i18n_dir</code></td><td style="text-align:center">国际化（i18n）文件夹</td><td style="text-align:center"><code>:lang</code></td></tr><tr><td style="text-align:center"><code>skip_render</code></td><td style="text-align:center">跳过指定文件的渲染。匹配到的文件会被不做改动地复制到<code>public</code>目录。可以使用 <a href="https://github.com/micromatch/micromatch#extended-globbing">glob 表达式</a>来匹配路径。</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><pre class="line-numbers language-lang-yaml"><code class="language-lang-yaml">skip_render: "mypage/**/*"# 将会直接将 `source/mypage/index.html` 和 `source/mypage/code.js` 不做改动地输出到 'public' 目录# 你也可以用这种方法来跳过对指定文章文件的渲染skip_render: "_posts/test-post.md"# 这将会忽略对 'test-post.md' 的渲染<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文章</p><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>new_post_name</code></td><td>新文章的文件名称</td><td><code>:title.md</code></td></tr><tr><td><code>default_layout</code></td><td>预设布局</td><td><code>poset</code></td></tr><tr><td><code>auto_spacing</code></td><td>在中文和英文之间加入空格</td><td><code>false</code></td></tr><tr><td><code>titlecase</code></td><td>把标题转换为 title case</td><td><code>false</code></td></tr><tr><td><code>external_link</code></td><td>在新标签中打开链接</td><td><code>true</code></td></tr><tr><td><code>external_link.enable</code></td><td>在新标签也中打开链接</td><td><code>true</code></td></tr><tr><td><code>external_link.field</code></td><td>对整个网站（<code>site</code>）生效或仅对文章（<code>post</code>）生效</td><td><code>site</code></td></tr><tr><td><code>external_link.exclude</code></td><td>需要排除的域名。主域名和子域名如<code>www</code>需分别配置</td><td><code>[]</code></td></tr><tr><td><code>filename_case</code></td><td>把文件名称转换为（1）小写或（2）大写</td><td><code>0</code></td></tr><tr><td><code>render_drafts</code></td><td>显示草稿</td><td><code>false</code></td></tr><tr><td><code>post_asset_folder</code></td><td>启动Asset文件夹</td><td><code>false</code></td></tr><tr><td><code>relative_link</code></td><td>把链接改为与根目录的相对地址</td><td><code>false</code></td></tr><tr><td><code>future</code></td><td>显示未来的文章</td><td><code>true</code></td></tr><tr><td><code>highlight</code></td><td>代码块的设置</td><td></td></tr><tr><td><code>prismjs</code></td><td>代码块的设置</td></tr></tbody></table></div><blockquote><p><strong>相对地址</strong></p><p>默认情况下，Hexo生成的超链接都是绝对地址。例如，如果你的网站域名为<code>example.com</code>，你有一篇文章名为<code>hello</code>，那么绝对链接可能像这样：<code>http://example.com/hello.html</code>，它是绝对于域名的。相对链接这样：<code>/hello.html</code>，也就是说无论用什么访问该站点，都没有关系，这在反向代理时可能用到，通常情况下，建议使用绝对地址。</p></blockquote><h3 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类&amp;标签"></a>分类&amp;标签</h3><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>default_category</code></td><td>默认分类</td><td><code>uncategorized</code></td></tr><tr><td><code>category_map</code></td><td>分类别名</td><td></td></tr><tr><td><code>tag_map</code></td><td>标签别名</td></tr></tbody></table></div><h3 id="日期-时间格式"><a href="#日期-时间格式" class="headerlink" title="日期/时间格式"></a>日期/时间格式</h3><p>Hexo使用 <a href="http://momentjs.com/">Moment.js</a> 来解析和显示时间。</p><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>date_format</code></td><td>日期格式</td><td><code>YYYY-MM-DD</code></td></tr><tr><td><code>time_format</code></td><td>时间格式</td><td><code>HH:mm:ss</code></td></tr><tr><td><code>updated_option</code></td><td>当Front Matter中没有指定<code>updated</code>时<code>updated</code>的取值</td><td><code>mtime</code></td></tr></tbody></table></div><blockquote><p><strong>updated_option</strong></p><p><code>updated_option</code>控制了当Front Matter中没有指定<code>updated</code>时，<code>updated</code>如何取值：</p><ul><li><code>mtime</code>: 使用文件的最后修改时间。这是从Hexo 3.0.0 开始的默认行为。</li><li><code>date</code>: 使用<code>date</code>作为<code>updated</code>的值。可被用于Git工作流之中，因为使用Git管理站点时，文件的最后修改日期常常会发生改变。</li><li><code>empty</code>: 直接删除<code>updated</code>。使用这一选项可能会导致大部分主题和插件无法正常工作。</li></ul><p><code>use_date_for_updated</code>选项已经被废弃，建议改为使用<code>updated_option: date</code></p></blockquote><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>per_apge</code></td><td>每页显示的文章两（0 = 关闭分页功能）</td><td><code>10</code></td></tr><tr><td><code>pagination_dir</code></td><td>分页目录</td><td><code>page</code></td></tr></tbody></table></div><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>theme</code></td><td>当前主题名称。值为<code>false</code>时禁用主题</td></tr><tr><td><code>theme_config</code></td><td>主题的配置文件。在这里放置的配置会覆盖主题目录下的<code>_config.yml</code>中的配置</td></tr><tr><td><code>deploy</code></td><td>配置部分的设置</td></tr><tr><td><code>meta_generator</code></td><td>Meta generator 标签。值为<code>false</code>时Hexo不会在头部插入该标签</td></tr></tbody></table></div><h4 id="包括或不包括目录和文件"><a href="#包括或不包括目录和文件" class="headerlink" title="包括或不包括目录和文件"></a>包括或不包括目录和文件</h4><p>在Hexo配置文件中，通过设置 <code>include/exclude</code>可以让Hexo进行处理或忽略某些目录和文件夹。你可以使用<a href="https://github.com/isaacs/minimatch">glob 表达式</a> 对目录和文件进行匹配。</p><p><code>include</code>和<code>exclude</code>选项，仅应用于<code>source/</code>文件夹下。<code>ignore</code>选项应用于所有文件夹。</p><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>include</code></td><td>Hexo默认会忽略隐藏文件和文件夹（包括名称以下划线和<code>.</code>开头的文件和文件夹，Hexo的<code>_posts</code>和<code>_data</code>等目录除外），通过设置此字段将使Hexo处理他们并将他们复制到<code>source</code>目录下</td></tr><tr><td><code>exclude</code></td><td>Hexo会忽略这些文件和目录</td></tr><tr><td><code>ignore</code></td><td>Ignore files/folders</td></tr></tbody></table></div><p>例如：</p><pre class="line-numbers language-lang-yaml"><code class="language-lang-yaml"># Include/Exclude Files/Foldersinclude:  - ".nojekyll"  # 包括 'source/css/_typing.css'  - "css/_typing.css"  # 包括 'source/_css/' 中的任何文件，但不包括子目录及其其中的文件。  - "_css/*"  # 包含 'source/_css/' 中的任何文件和子目录下的任何文件  - "_css/**/*"exclude:  # 不包括 'source/js/test.js'  - "js/test.js"  # 不包括 'source/js/' 中的文件、但包括子目录下的所有目录和文件  - "js/*"  # 不包括 'source/js/' 中的文件和子目录下的任何文件  - "js/**/*"  # 不包括 'source/js/' 目录下的所有文件名以 'test' 开头的文件，但包括其它文件和子目录下的单文件  - "js/test*"  # 不包括 'source/js/' 及其子目录中任何以 'test' 开头的文件  - "js/**/test*"  # 不要用 exclude 来忽略 'source/_posts/' 中的文件。你应该使用 'skip_render'，或者在要忽略的文件的文件名之前加一个下划线 '_'  # 在这里配置一个 - "_posts/hello-world.md" 是没有用的。ignore:  # Ignore any folder named 'foo'.  - "**/foo"  # Ignore 'foo' folder in 'themes/' only.  - "**/themes/*/foo"  # Same as above, but applies to every subfolders of 'themes/'.  - "**/themes/**/foo"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>列表中的每一项都必须用单引号或双引号包裹起来。</p><p><code>include</code>和<code>exclude</code>并不适用于<code>themes/</code>目录下的文件。如果需要忽略<code>themes/</code>目录下的部分文件或文件夹，可以使用<code>ignore</code>或在文件名之前添加<code>_</code>。</p><h3 id="使用代替配置文件"><a href="#使用代替配置文件" class="headerlink" title="使用代替配置文件"></a>使用代替配置文件</h3><p>可以在<code>`hexo-cli</code>中使用<code>--config</code>参数来指定自定义配置文件的路径。你可以使用一个<code>yaml</code>或<code>json</code>文件的路径，也可以使用都好分割（无空格）的多个<code>yaml</code>或<code>json</code>文件的路径。例如：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># user 'custom.yml' in place of '_config.yml'$ hexo server --config custom.yml# use 'custom.yml' & 'custom2.json' , prioritizing 'custom3.yml' then 'custom2.json'$ hexo generate --config custom.yml,custom2.json,custom3.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当你指定了多个配置文件以后，Hexo会按顺序将这部分配置文件合成一个<code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则使用于任意数量、任意深度的<code>yaml</code>和<code>json</code>文件。</p><p>例如，使用<code>--options</code>指定了两个自定义配置文件：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo generate --config custom.yml,custom2.json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果<code>custom.yml</code>中指定了<code>foo:bar</code>，在<code>custom2.json</code>中指定了<code>&quot;foo&quot;:&quot;dinosaur&quot;</code>，那么在<code>_multiconfig.yml</code>中你会得到<code>foo:dinosaur</code>。</p><h3 id="使用代替主题配置文件"><a href="#使用代替主题配置文件" class="headerlink" title="使用代替主题配置文件"></a>使用代替主题配置文件</h3><p>通常情况下，Hexo主题是一个独立的项目，并拥有一个独立的<code>_config.yml</code>配置文件。除了自行维护独立的主题配置文件，你也可以在其他地方对主题进行配置。</p><h4 id="配置文件中的theme-config"><a href="#配置文件中的theme-config" class="headerlink" title="配置文件中的theme_config"></a>配置文件中的<code>theme_config</code></h4><blockquote><p>该特性自 Hexo 2.8.2 起提供</p></blockquote><pre class="line-numbers language-lang-yaml"><code class="language-lang-yaml"># _config.ymltheme: "my-theme"theme_config:    bio: "My awesome bio"    foo:        bar: 'a'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-yaml"><code class="language-lang-yaml"># themes/my-theme/_config.ymlbio: "Some generic bio"logo: "a-cool-image.png"    foo:         baz: 'b'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终主题配置的输出时：</p><pre class="line-numbers language-lang-yaml"><code class="language-lang-yaml">&#123;    bio: "My awesome bio",    logo: "a-cool-image.png",    foo:&#123;        bar: "a",        baz: "b"    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="独立的-config-theme-yml文件"><a href="#独立的-config-theme-yml文件" class="headerlink" title="独立的 _config.[theme].yml文件"></a>独立的 <code>_config.[theme].yml</code>文件</h4><blockquote><p>该特性自Hexo 5.0.0 起提供</p></blockquote><p>独立的主题配置文件应放置于站点根目录下，支持<code>yml</code>或<code>json</code>格式。需要配置站点<code>_config.yml</code>文件中的<code>theme</code>以供Hexo寻找<code>_config.[theme].yml</code>文件。</p><pre class="line-numbers language-lang-yaml"><code class="language-lang-yaml"># _config.ymltheme: "my-theme"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-yaml"><code class="language-lang-yaml"># _config.my-theme.ymlbio: "My awesome bio"foo:    bar: 'a'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-yaml"><code class="language-lang-yaml"># themes/my-theme/_configbio: "Some Generic bio"logo: "a-cool-image.png"    foo:        baz: 'b'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终主题配置的输出是：</p><pre class="line-numbers language-lang-yaml"><code class="language-lang-yaml">&#123;    bio: "My awesome bio",    logo: "a-cool-image.png",    foo:&#123;        bar: "a",        baz: "b"    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>我们强烈建议你将所有的主题配置集中在一处。如果你不得不在多处配置你的主题，那么这些信息对你将会非常有用：Hexo在合并主题配置时，Hexo配置文件中的<code>theme_config</code>的优先级最高，其次是<code>_config.[theme].yml</code>文件，最后是位于主题目录下的<code>_config.yml</code>文件。</p></blockquote><h2 id="Hexo命令"><a href="#Hexo命令" class="headerlink" title="Hexo命令"></a>Hexo命令</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo init <folder><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新建一个网站。如果没有设置<code>&lt;folder&gt;</code>，Hexo默认在当前的文件夹建立网站。</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo new [layout] <title><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新建一篇文章。</p><p>如果没有设置<code>layout</code>的话，默认使用<code>_config.yml</code>中的<code>default_layout</code>参数代替。如果标题包含空格的话，请使用引号括起来。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo new "post title with whitespace"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-p</code>，<code>--path</code></td><td>自定义新文章的路径</td></tr><tr><td><code>-r</code>，<code>--replace</code></td><td>如果存在同名文章，将其替换</td></tr><tr><td><code>-s</code>，<code>--slug</code></td><td>文章的Slug，作为新文章的文件名和发布后的URL</td></tr></tbody></table></div><p>默认情况下，Hexo会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo会创建一个义标题为名字的目录，并在目录中放置一个<code>index.md</code>文件。你可以使用<code>--path</code>参数来覆盖上述行为、自行决定文件的目录：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo new page --path about/me "About me"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上命令会创建一个<code>source/about/me.md</code>文件，同时Front Matter中的<code>&lt;title&gt;</code>为<code>&quot;About me&quot;</code></p><p><strong>注意</strong>：title时必须指定的!如果你这么做并不能达到你的目的：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo new page --path about/me<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时Hexo会创建一个<code>source/about/me.md</code>文件，同时<code>me.md</code>的 Front Matter中的title 为 <code>“page”</code>。这是因为在上述命令中，<code>hexo-cli</code>将<code>page</code>视为指定文章的标题、并采用默认的<code>layout</code>。</p><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成静态文件。</p><div class="table-container"><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-d</code>，<code>--deploy</code></td><td>文件生成后立即部署网站</td></tr><tr><td><code>-w</code>，<code>--watch</code></td><td>监视文件变动</td></tr><tr><td><code>-b</code>，<code>--bail</code></td><td>生成过程中如果发生任何为处理的异常则抛出异常</td></tr><tr><td><code>-f</code>，<code>--force</code></td><td>强制重新生成文件，Hexo引入了差分机制，如果<code>public</code>目录存在，那么<code>hexo g</code>只会重新生成改动的文件。使用该参数效果接近<code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td><code>-c</code>，<code>--concurrency</code></td><td>最大同时生成的文件数量，默认无限制</td></tr></tbody></table></div><p>该命令可以简写为：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo publish [layout] <filename><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发表草稿</p><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动服务器。默认情况下，访问网址为：<code>http://localhost:4000</code>。</p><div class="table-container"><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-p</code>，<code>--port</code></td><td>重设端口</td></tr><tr><td><code>-s</code>，<code>--static</code></td><td>只使用静态文件</td></tr><tr><td><code>-l</code>，<code>--log</code></td><td>启动日记记录，使用覆盖记录格式</td></tr></tbody></table></div><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>部署网站。</p><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-g</code>，<code>--generate</code></td><td>部署之前预先生成静态文件</td></tr></tbody></table></div><p>改命令可以简写为：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo render <file1> [file2] ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染文件。</p><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-o</code>，<code>--output</code></td><td>设置输出路径</td></tr></tbody></table></div><h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo migrate <type<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从其他博客系统迁移内容。</p><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>清楚缓存文件(<code>db.json</code>)和以生成的静态文件(<code>public</code>)。</p><p>在某些情况（尤其时更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo list <type><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>列出网站资料。</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示Hexo版本。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><h4 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h4><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo --safe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题是，可以尝试以安全模式重新执行。</p><h4 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h4><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">hexo --debug<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在终端中显示调试信息并记录到<code>debug.log</code>。当您碰到问题是，可以尝试用调试模式重新执行一次，并提交调试信息到GitHub。</p><h4 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h4><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo --silent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>隐藏终端信息。</p><h4 id="自定以配置文件的路径"><a href="#自定以配置文件的路径" class="headerlink" title="自定以配置文件的路径"></a>自定以配置文件的路径</h4><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 使用 custom.yml 代替默认的 _config.yml$ hexo server --config custom.yml# 使用 custom.yml 和 custom2.json, 其中 custom2.json 优先级更高$ hexo generate --config custom.yml,custom2.json,custom3.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义配置文件的路径，指定这个参数后将不再使用默认的<code>_config.yml</code>。</p><p>你可以使用一个<code>yaml</code>或<code>json</code>文件的路径，也可以使用逗号分割（无空格）的多个<code>yaml</code>和<code>json</code>文件的路径。例如</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 使用 custom.yml 代替默认的 _config.yml$ hexo server --config custom.yml# 使用 custom.yml,custom2.json 和 custom3.yml,其中 custom3.yml优先级最高，其次时 custom2.json$ hexo generate --config custom.yml,custom2.json,custom3.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当你指定了多个配置文件以后，Hexo会按顺序将这部分配置文件合并成一个<code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则使用于任意数量、任意深度的<code>yaml</code>和<code>json</code>文件。</p><h4 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h4><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo --draft<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示<code>source/_drafts</code>文件夹中的草稿文章。</p><h4 id="自定以-CWD"><a href="#自定以-CWD" class="headerlink" title="自定以 CWD"></a>自定以 CWD</h4><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo --cwd /path/to/cwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>自定义当前工作目录（Current working directory）的路径。</p><h2 id="Hexo-迁移"><a href="#Hexo-迁移" class="headerlink" title="Hexo 迁移"></a>Hexo 迁移</h2><p>首先，是安装插件</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 其中<arch>表示博客的架构平台$ npm install hexo-migrator-<arch> --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>插件安装完成后，执行下列命令，从<code>&lt;arch&gt;</code>迁移所有稳占。<code>source</code>可以时文件路径或网址。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo migrate <arch> <source><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><a href="https://hexo.io/zh-cn/docs/migration">https://hexo.io/zh-cn/docs/migration</a></p><footer><strong>参考Hexo官网迁移</strong></footer></blockquote><h2 id="Hexo写作"><a href="#Hexo写作" class="headerlink" title="Hexo写作"></a>Hexo写作</h2><p>你可以执行下列命令来创建一篇新文章或者新的页面</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo new [layout] <title><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo-GitHub搭建个人博客</title>
      <link href="posts/29191.html"/>
      <url>posts/29191.html</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>操作系统：Window 10</li><li>Node.js</li><li>Hexo</li><li>Git</li><li>一个GitHub帐号</li><li>一个云服务器（可选）</li><li>一个域名（可选）</li></ul><h3 id="安装Chocolatey"><a href="#安装Chocolatey" class="headerlink" title="安装Chocolatey"></a>安装Chocolatey</h3><ol><li><p>以管理员身份运行 Windows PowerShell。</p></li><li><p>将下面的命令行代码输入到 PowerShell中</p><pre><code> Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString(&#39;https://chocolatey.org/install.ps1&#39;))</code></pre></li><li><p>等待完成安装</p></li><li><p>在PowerShell终端中输入 <code>choco</code>或<code>choco -?</code>检测是否安装成功。</p> <blockquote> <span style="font-size:20px"><b>Refrence</b></span>     <br>     <a href="https://chocolatey.org/install):https://chocolatey.org/install">官网</a>     <br>     <a href="https://sitoi.cn/posts/46278.html#Windows-程序包管理器-Chocolatey：一条命令装软件">某位大佬的博客</a> </blockquote></li></ol><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><h4 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h4><p>以<strong>管理员</strong>权限打开<strong>PowerShell</strong>，输入以下的命令</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">choco install nodejs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="检测nodejs是否安装成功"><a href="#检测nodejs是否安装成功" class="headerlink" title="检测nodejs是否安装成功"></a>检测nodejs是否安装成功</h4><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">npm -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="修改npm源"><a href="#修改npm源" class="headerlink" title="修改npm源"></a>修改npm源</h4><p>由于官方npm源下载的速度太慢，所以我们需要将npm源替换成<strong>淘宝源</strong>。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">npm config set registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>以管理员权限打开PowerShell，输入以下命令，推荐安装4.1.1版本：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">npm i hexo@4.1.1 -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><h4 id="安装Git-1"><a href="#安装Git-1" class="headerlink" title="安装Git"></a>安装Git</h4><p>以管理员权限打开PowerShell，输入以下命令：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">choco install git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="检测Git是否安装成功"><a href="#检测Git是否安装成功" class="headerlink" title="检测Git是否安装成功"></a>检测Git是否安装成功</h4><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">git --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="注册GitHub帐号"><a href="#注册GitHub帐号" class="headerlink" title="注册GitHub帐号"></a>注册GitHub帐号</h3><p>注册地址：<a href="http://github.com/join?source=header">http://github.com/join?source=header</a></p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>创建一个仓库，用于托管博客代码</p><ul><li><p>仓库的命令格式必须为：<code>&lt;用户名&gt;.github.io</code></p></li><li><p><code>Description</code>：描述仓库（选填）</p></li><li><p>勾选<code>Initialize this repository with a README</code> 初始化一个README.md文件。</p></li><li><p>点击<code>Creat repository</code>创建，然后项目就建成了。</p><p>  <img src="/posts/29191/Create-Repository.png" alt="Create Repository"></p></li></ul><h3 id="访问你的个人网站"><a href="#访问你的个人网站" class="headerlink" title="访问你的个人网站"></a>访问你的个人网站</h3><p>打开浏览器，输入网站：<code>&lt;用户名&gt;.github.com</code>，例如`pantsuit.github.io</p><p><img src="/posts/29191/GitHub-Page.png" alt="Github Page"></p><h3 id="为GitHub配置SSh-Key"><a href="#为GitHub配置SSh-Key" class="headerlink" title="为GitHub配置SSh Key"></a>为GitHub配置SSh Key</h3><h4 id="打开-GitBash"><a href="#打开-GitBash" class="headerlink" title="打开 GitBash"></a>打开 GitBash</h4><p>在Window桌面上，鼠标右击，选择Git Bash Here，打开Git Bash：</p><p> <img src="/posts/29191/mouse-hit-for-git-bash.png" alt="Open Git Bash"></p><p><img src="/posts/29191/git-bash.png" alt="Git Bash"></p><h4 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h4><p>输入以下命令，其中<code>email@email.com</code>填入为你自己的邮箱。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">ssh-keygen -t rsa -C "email@email.com"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="将SSH-Key-添加到GitHub"><a href="#将SSH-Key-添加到GitHub" class="headerlink" title="将SSH Key 添加到GitHub"></a>将SSH Key 添加到GitHub</h4><ol><li>点击头像，进入Setting页面</li><li>点击 <code>SSH and GPG keys</code>，进入<code>ssh and GPG keys</code>管理页面</li><li>添加SSH Key</li></ol><p><img src="/posts/29191/add-ssh-key.png" alt="Add ssh key"></p><p>​    4.输入生成的公钥（以.pub文件结尾的文件），并点击添加。</p><p><img src="/posts/29191/input-ssh-key.png" alt="input ssh public key"></p><h4 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h4><p>打开Git Bash 输入以下命令：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">ssh -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><h3 id="初始化Hexo-项目"><a href="#初始化Hexo-项目" class="headerlink" title="初始化Hexo 项目"></a>初始化Hexo 项目</h3><p>选择一个目录，在当前目录打开命令行窗口，输入如下命令:<code>hexo init &lt;directoryname&gt;</code></p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">hexo init asd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果文件夹不存在，会创建该文件夹。运行命令后，会将Hexo 的初始化文件下载到该目录。包括<code>themes</code>、<code>scaffolds</code>、<code>source</code>等文件夹。</p><h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><p>切换到hexo博客根目录，运行如下命令：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">npm i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="启动hexo博客"><a href="#启动hexo博客" class="headerlink" title="启动hexo博客"></a>启动hexo博客</h3><p>运行如下命令：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看博客"><a href="#查看博客" class="headerlink" title="查看博客"></a>查看博客</h3><p>打开浏览器，输入地址 <a href="http://localhost:4000/">http://localhost:4000/</a> 看到下面的效果，说明你得博客构建成功了。</p><p><img src="/posts/29191/blog_init.png" alt="Blog Init"></p><h3 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h3><h4 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h4><h5 id="安装hexo-deployer-git-插件"><a href="#安装hexo-deployer-git-插件" class="headerlink" title="安装hexo-deployer-git 插件"></a>安装hexo-deployer-git 插件</h5><p>切换到Hexo博客项目目录，运行如下命令：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="修改-config-yml文件"><a href="#修改-config-yml文件" class="headerlink" title="修改 _config.yml文件"></a>修改 _config.yml文件</h5><p>配置站点信息</p><p><img src="/posts/29191/hexo_config.png" alt="Hexo Config"></p><p>添加部署信息</p><p>修改前：</p><pre class="line-numbers language-lang-yaml"><code class="language-lang-yaml"># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: ''<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>修改后：</p><pre class="line-numbers language-lang-yaml"><code class="language-lang-yaml"># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: https://github.com/PANTSUIT/PANTSUIT.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="部署项目到GitHub"><a href="#部署项目到GitHub" class="headerlink" title="部署项目到GitHub"></a>部署项目到GitHub</h5><p>修改好配置后，运行如下命令，将代码部署到GitHub</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">hexo genreatehexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="查看部署情况"><a href="#查看部署情况" class="headerlink" title="查看部署情况"></a>查看部署情况</h5><p>打开浏览器访问 <a href="https://pantsuit.github.io">https://pantsuit.github.io</a> 这时我们就可以看到跟本地一模一样的博客内容了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
